{"version":3,"sources":["../code/index.js"],"names":["assert","require","babylon","tt","tokTypes","Parser","hookBabylon","baseProto","prototype","pp","Object","create","tgt_patch","braceL","fn_updateContext","updateContext","prevType","constructor","parse","Error","initOffside","call","OffsideBreakout","offsideBreakout","state","offside","offside_lines","parseOffsideIndexMap","input","_pos","pos","defineProperty","enumerable","get","set","offPos","offsidePos","tt_offside","braceR","parenL","parenR","bracketL","bracketR","at_offside","tokenPre","tokenPost","nestInner","extraChars","finishToken","type","val","op","at","doubleColon","pos0","start","pos1","str_op","slice","split","finishOffsideOp","eof","length","popOffside","offsideBlock","stackTop","line0","curLine","first","line","indent","innerIndent","last","cur","content","isLookahead","stack","blk","push","skipSpace","posLastContent","err","readToken","code","pop","tt_post","rx_offside","lines","ans","replace","match","module","exports","babel","manipulateOptions","opts","parserOpts","plugins","assign"],"mappings":"AAAA;;AACA,MAAMA,SAASC,QAAQ,QAAR,CAAf;AACA,MAAMC,UAAUD,QAAQ,SAAR,CAAhB;AACA,MAAME,KAAKD,QAAQE,QAAnB;;AAEA,MAAMC,SAASC,aAAf;AACA,MAAMC,YAAYF,OAAOG,SAAzB;AACA,MAAMC,KAAKJ,OAAOG,SAAP,GAAmBE,OAAOC,MAAP,CAAcJ,SAAd,CAA9B;;AAEA,SAASD,WAAT,GAAuB;AACrB;AACA;;AAEA,MAAID,MAAJ;AACA,MAAIO,YAAYV,QAAQE,QAAR,CAAiBS,MAAjC;AACA,MAAIC,mBAAmBF,UAAUG,aAAjC;AACAH,YAAUG,aAAV,GAA0B,UAAUC,QAAV,EAAoB;AAC5CJ,cAAUG,aAAV,GAA0BD,gBAA1B;AACAT,aAAS,KAAKY,WAAd;AAAyB,GAF3B;;AAIAf,UAAQgB,KAAR,CAAc,IAAd;AACA,MAAI,CAACb,MAAL,EACE,MAAM,IAAIc,KAAJ,CAAY,+BAAZ,CAAN;AACF,SAAOd,MAAP;AAAa;;AAIfI,GAAGS,KAAH,GAAW,YAAW;AACpB,OAAKE,WAAL;AACA,SAAOb,UAAUW,KAAV,CAAgBG,IAAhB,CAAqB,IAArB,CAAP;AAAiC,CAFnC;;AAKA,MAAMC,eAAN,SAA8BH,KAA9B,CAAoC;AACpC,MAAMI,kBAAkB,IAAID,eAAJ,EAAxB;;AAEAb,GAAGW,WAAH,GAAiB,YAAW;AAC1B,OAAKI,KAAL,CAAWC,OAAX,GAAqB,EAArB;AACA,OAAKC,aAAL,GAAqBC,qBAAqB,KAAKC,KAA1B,CAArB;;AAEA,OAAKJ,KAAL,CAAWK,IAAX,GAAkB,KAAKL,KAAL,CAAWM,GAA7B;AACApB,SAAOqB,cAAP,CAAwB,KAAKP,KAA7B,EAAoC,KAApC,EACE,EAAIQ,YAAY,IAAhB;AACIC,UAAM;AAAG,aAAO,KAAKJ,IAAZ;AAAgB,KAD7B,EAEIK,IAAIJ,GAAJ,EAAS;AACP;AACA,UAAIK,SAAS,KAAKC,UAAlB;AACA,UAAID,UAAQ,CAAR,IAAcL,MAAMK,MAAxB,EACE,MAAMZ,eAAN;;AAEF,WAAKM,IAAL,GAAYC,GAAZ;AAAe,KARrB,EADF;AASuB,CAdzB;;AAiBA,IAAIO,aACF,EAAI,KAAKlC,GAAGU,MAAZ,EAAsB,KAAKV,GAAGmC,MAA9B;AACI,OAAKnC,GAAGoC,MADZ,EACsB,KAAKpC,GAAGqC,MAD9B;AAEI,OAAKrC,GAAGsC,QAFZ,EAEsB,KAAKtC,GAAGuC,QAF9B,EADF;;AAKA,IAAIC,aACF,EAAI,MAAQ,EAACC,UAAU,GAAX,EAAgBC,WAAW,GAA3B,EAAgCC,WAAW,KAA3C,EAAZ;AACI,SAAQ,EAACF,UAAU,GAAX,EAAgBC,WAAW,GAA3B,EAAgCC,WAAW,KAA3C,EAAkDC,YAAY,CAA9D,EADZ;AAEI,UAAQ,EAACH,UAAU,GAAX,EAAgBC,WAAW,GAA3B,EAAgCC,WAAW,KAA3C,EAAkDC,YAAY,CAA9D,EAFZ;AAGI,UAAQ,EAACH,UAAU,GAAX,EAAgBC,WAAW,GAA3B,EAAgCC,WAAW,KAA3C,EAAkDC,YAAY,CAA9D,EAHZ;AAII,UAAQ,EAACH,UAAU,GAAX,EAAgBC,WAAW,GAA3B,EAAgCC,WAAW,KAA3C,EAAkDC,YAAY,CAA9D,EAJZ;AAKI,OAAQ,EAACH,UAAU,GAAX,EAAgBC,WAAW,GAA3B,EAAgCC,WAAW,IAA3C,EALZ;AAMI,SAAQ,EAACF,UAAU,GAAX,EAAgBC,WAAW,GAA3B,EAAgCC,WAAW,IAA3C,EAAiDC,YAAY,CAA7D,EANZ;AAOI,SAAQ,EAACH,UAAU,GAAX,EAAgBC,WAAW,GAA3B,EAAgCC,WAAW,IAA3C,EAAiDC,YAAY,CAA7D,EAPZ;AAQI,SAAQ,EAACH,UAAU,GAAX,EAAgBC,WAAW,GAA3B,EAAgCC,WAAW,IAA3C,EAAiDC,YAAY,CAA7D;AACV;AATF,CADF,CAYAtC,GAAGuC,WAAH,GAAiB,UAASC,IAAT,EAAeC,GAAf,EAAoB;AACnC,MAAIC,EAAJ;AACA,MAAIhD,GAAGiD,EAAH,KAAUH,IAAV,IAAkB9C,GAAGkD,WAAH,KAAmBJ,IAAzC,EAA+C;AAC7C,UAAMK,OAAO,KAAK9B,KAAL,CAAW+B,KAAxB;AAAA,UAA+BC,OAAO,KAAKhC,KAAL,CAAWM,GAAX,GAAiB,CAAvD;AACA,UAAM2B,SAAS,KAAK7B,KAAL,CAAW8B,KAAX,CAAiBJ,IAAjB,EAAuBE,IAAvB,EAA6BG,KAA7B,CAAmC,IAAnC,EAAyC,CAAzC,EAA4C,CAA5C,CAAf;;AAEAR,SAAKR,WAAWc,MAAX,CAAL;AACA,QAAIN,EAAJ,EAAQ,OAAO,KAAKS,eAAL,CAAqBT,EAArB,CAAP;AAA+B;;AAGzC,MAAIhD,GAAG0D,GAAH,KAAWZ,IAAf,EAAqB;AACnB,QAAI,KAAKzB,KAAL,CAAWC,OAAX,CAAmBqC,MAAvB,EAA+B;AAC7B,aAAO,KAAKC,UAAL,EAAP;AAAwB;AAAA;;AAG5B,SAAOxD,UAAUyC,WAAV,CAAsB3B,IAAtB,CAA2B,IAA3B,EAAiC4B,IAAjC,EAAuCC,GAAvC,CAAP;AAAkD,CAfpD;;AAmBAzC,GAAGuD,YAAH,GAAkB,UAAUb,EAAV,EAAcc,QAAd,EAAwB;AACxC,MAAIvC,gBAAgB,KAAKA,aAAzB;;AAEA,QAAMwC,QAAQ,KAAK1C,KAAL,CAAW2C,OAAzB;AACA,QAAMC,QAAQ1C,cAAcwC,KAAd,CAAd;AACA,QAAMpB,YAAYK,GAAGL,SAAH,IAAgBmB,QAAhB,IAA4BC,UAAUD,SAASG,KAAT,CAAeC,IAAvE;AACA,QAAMC,SAASxB,YAAYmB,SAASM,WAArB,GAAmCH,MAAME,MAAxD;AACA,MAAID,OAAO,IAAEH,KAAb;AAAA,MAAoBM,OAAOJ,KAA3B;AACA,MAAIG,cAAc7C,cAAc2C,IAAd,EAAoBC,MAAtC;;AAEA,SAAOD,OAAO3C,cAAcoC,MAA5B,EAAoC;AAClC,QAAIW,MAAM/C,cAAc2C,IAAd,CAAV;AACA,QAAII,IAAIC,OAAJ,IAAeJ,UAAUG,IAAIH,MAAjC,EAAyC;AACvC;AAAK;;AAEPD,WAAQG,OAAOC,GAAP;AACR,QAAIF,cAAcE,IAAIH,MAAtB,EAA8B;AAC5BC,oBAAcE,IAAIH,MAAlB;AAAwB;AAAA;;AAE5B;AACAC,gBAAcH,MAAME,MAAN,GAAeC,WAAf,GACVH,MAAME,MADI,GACKC,WADnB;;AAGA,SAAO,EAACpB,EAAD,EAAKoB,WAAL,EAAkBH,KAAlB,EAAyBI,IAAzB,EAA+B1B,SAA/B,EAAP;AAAgD,CAvBlD;;AA0BArC,GAAGmD,eAAH,GAAqB,UAAUT,EAAV,EAAc;AACjC,MAAIG,OAAO,KAAK9B,KAAL,CAAWM,GAAtB;AACA,MAAIqB,GAAGJ,UAAP,EACE,KAAKvB,KAAL,CAAWM,GAAX,IAAkBqB,GAAGJ,UAArB;;AAEF,OAAKC,WAAL,CAAiBX,WAAWc,GAAGP,QAAd,CAAjB;AACA,MAAI,KAAK+B,WAAT,EAAsB;;AAEtB,MAAIC,QAAQ,KAAKpD,KAAL,CAAWC,OAAvB;AACA,MAAIwC,WAAWW,MAAMA,MAAMd,MAAN,GAAe,CAArB,CAAf;AACA,MAAIe,MAAM,KAAKb,YAAL,CAAkBb,EAAlB,EAAsBc,QAAtB,CAAV;AACA,OAAKzC,KAAL,CAAWC,OAAX,CAAmBqD,IAAnB,CAAwBD,GAAxB;AAA4B,CAX9B;;AAcApE,GAAGsE,SAAH,GAAe,YAAW;AACxB,MAAId,QAAJ;AAAA,MAAcW,QAAQ,KAAKpD,KAAL,CAAWC,OAAjC;AACA,MAAImD,SAASA,MAAMd,MAAnB,EAA2B;AACzBG,eAAWW,MAAMA,MAAMd,MAAN,GAAa,CAAnB,CAAX;AACA,SAAKtC,KAAL,CAAWY,UAAX,GAAwB6B,SAASO,IAAT,CAAcQ,cAAtC;AAAoD,GAFtD,MAGK,KAAKxD,KAAL,CAAWY,UAAX,GAAwB,CAAC,CAAzB;;AAEL,MAAI;AACF7B,cAAUwE,SAAV,CAAoB1D,IAApB,CAAyB,IAAzB;AACA,SAAKG,KAAL,CAAWY,UAAX,GAAwB,CAAC,CAAzB;AAA0B,GAF5B,CAGA,OAAO6C,GAAP,EAAY;AACV,QAAIA,QAAQ1D,eAAZ,EAA6B,MAAM0D,GAAN;AAAU;AAAA,CAX3C;;AAcAxE,GAAGyE,SAAH,GAAe,UAASC,IAAT,EAAe;AAC5B,MAAI,KAAK3D,KAAL,CAAWM,GAAX,KAAmB,KAAKN,KAAL,CAAWY,UAAlC,EACE,OAAO7B,UAAU2E,SAAV,CAAoB7D,IAApB,CAAyB,IAAzB,EAA+B8D,IAA/B,CAAP;;AAEF,SAAO,KAAKpB,UAAL,EAAP;AAAwB,CAJ1B;;AAMAtD,GAAGsD,UAAH,GAAgB,YAAW;AACzB,MAAIa,QAAQ,KAAKpD,KAAL,CAAWC,OAAvB;AACA,MAAIwC,WAAW,KAAKU,WAAL,GACXC,MAAMA,MAAMd,MAAN,GAAa,CAAnB,CADW,GAEXc,MAAMQ,GAAN,EAFJ;AAGA,OAAK5D,KAAL,CAAWY,UAAX,GAAwB,CAAC,CAAzB;;AAEA,MAAIiD,UAAUhD,WAAW4B,SAASd,EAAT,CAAYN,SAAvB,CAAd;AACA,OAAKG,WAAL,CAAiBqC,OAAjB;AACA,SAAOA,OAAP;AAAc,CAThB;;AAaA,MAAMC,aAAa,kBAAnB;AACA,SAAS3D,oBAAT,CAA8BC,KAA9B,EAAqC;AACnC,MAAI2D,QAAQ,CAAC,IAAD,CAAZ;AAAA,MAAoBP,iBAAe,CAAnC;AAAA,MAAsCR,OAAK,CAAC,EAAD,EAAK,CAAL,CAA3C;;AAEA,MAAIgB,MAAM5D,MAAM6D,OAAN,CAAgBH,UAAhB,EAA4B,CAACI,KAAD,EAAQpB,MAAR,EAAgBI,OAAhB,EAAyB5C,GAAzB,KAAiC;AACrE,QAAI,CAAC4C,OAAL,EAAc;AACZ,OAACJ,MAAD,EAASU,cAAT,IAA2BR,IAA3B,CADY,CACoB;AAA4C,KAD9E,MAEK;AACH;AACAQ,yBAAiBlD,MAAM4D,MAAM5B,MAA7B;AACAU,eAAO,CAACF,MAAD,EAASU,cAAT,CAAP;AAA+B;;AAEjCO,UAAMT,IAAN,CAAW,EAACT,MAAMkB,MAAMzB,MAAb,EAAqBkB,cAArB,EAAqCV,MAArC,EAA6CI,OAA7C,EAAX;AACA,WAAO,EAAP;AAAS,GATD,CAAV;;AAWA,SAAOa,KAAP;AAAY;;AAIdI,OAAOC,OAAP,GAAiBA,UAAWC,KAAD,KACzB;AACEC,oBAAkBC,IAAlB,EAAwBC,UAAxB,EAAoC;AAClCA,eAAWC,OAAX,CAAmBnB,IAAnB,CAAwB,YAAxB,EAAsC,cAAtC;AAAqD,GAFzD,EADyB,CAA3B;;AAMApE,OAAOwF,MAAP,CAAgBN,OAAhB,EACE;AACEtF,aADF;AAEEqB,sBAFF,EADF","file":"index.js","sourcesContent":["'use strict'\nconst assert = require('assert')\nconst babylon = require('babylon')\nconst tt = babylon.tokTypes\n\nconst Parser = hookBabylon()\nconst baseProto = Parser.prototype\nconst pp = Parser.prototype = Object.create(baseProto)\n\nfunction hookBabylon() ::\n  // abuse Babylon token updateContext callback extract\n  // the reference to Parser\n\n  let Parser\n  let tgt_patch = babylon.tokTypes.braceL\n  let fn_updateContext = tgt_patch.updateContext\n  tgt_patch.updateContext = function (prevType) ::\n    tgt_patch.updateContext = fn_updateContext\n    Parser = this.constructor\n\n  babylon.parse('{}')\n  if (!Parser)\n    throw new Error @ \"Failed to hook Babylon Parser\"\n  return Parser\n\n\n\npp.parse = function() ::\n  this.initOffside()\n  return baseProto.parse.call(this)\n\n\nclass OffsideBreakout extends Error {}\nconst offsideBreakout = new OffsideBreakout()\n\npp.initOffside = function() ::\n  this.state.offside = []\n  this.offside_lines = parseOffsideIndexMap(this.input)\n\n  this.state._pos = this.state.pos\n  Object.defineProperty @ this.state, 'pos',\n    @{} enumerable: true\n      , get() :: return this._pos\n      , set(pos) ::\n          // interrupt skipSpace algorithm when we hit our position 'breakpoint'\n          let offPos = this.offsidePos\n          if (offPos>=0 && (pos > offPos))\n            throw offsideBreakout\n\n          this._pos = pos\n\n\nlet tt_offside =\n  @{} '{': tt.braceL,   '}': tt.braceR\n    , '(': tt.parenL,   ')': tt.parenR\n    , '[': tt.bracketL, ']': tt.bracketR\n\nlet at_offside =\n  @{} '::':   {tokenPre: '{', tokenPost: '}', nestInner: false}\n    , '::@':  {tokenPre: '(', tokenPost: ')', nestInner: false, extraChars: 1}\n    , '::()': {tokenPre: '(', tokenPost: ')', nestInner: false, extraChars: 2}\n    , '::{}': {tokenPre: '{', tokenPost: '}', nestInner: false, extraChars: 2}\n    , '::[]': {tokenPre: '[', tokenPost: ']', nestInner: false, extraChars: 2}\n    , '@':    {tokenPre: '(', tokenPost: ')', nestInner: true}\n    , '@()':  {tokenPre: '{', tokenPost: '}', nestInner: true, extraChars: 2}\n    , '@{}':  {tokenPre: '{', tokenPost: '}', nestInner: true, extraChars: 2}\n    , '@[]':  {tokenPre: '[', tokenPost: ']', nestInner: true, extraChars: 2}\n    // note:  no '@()' -- standardize to use single-char '@ ' instead\n\npp.finishToken = function(type, val) ::\n  let op\n  if (tt.at === type || tt.doubleColon === type) ::\n    const pos0 = this.state.start, pos1 = this.state.pos + 2\n    const str_op = this.input.slice(pos0, pos1).split(/\\s/, 1)[0]\n\n    op = at_offside[str_op]\n    if (op) return this.finishOffsideOp(op)\n\n\n  if (tt.eof === type) ::\n    if (this.state.offside.length) ::\n      return this.popOffside()\n\n\n  return baseProto.finishToken.call(this, type, val)\n\n\n\npp.offsideBlock = function (op, stackTop) ::\n  let offside_lines = this.offside_lines\n\n  const line0 = this.state.curLine\n  const first = offside_lines[line0]\n  const nestInner = op.nestInner && stackTop && line0 === stackTop.first.line\n  const indent = nestInner ? stackTop.innerIndent : first.indent\n  let line = 1+line0, last = first\n  let innerIndent = offside_lines[line].indent\n\n  while (line < offside_lines.length) ::\n    let cur = offside_lines[line]\n    if (cur.content && indent >= cur.indent) ::\n      break\n\n    line++; last = cur\n    if (innerIndent > cur.indent) ::\n      innerIndent = cur.indent\n\n  // cap to \n  innerIndent = first.indent > innerIndent\n    ? first.indent : innerIndent\n\n  return {op, innerIndent, first, last, nestInner}\n\n\npp.finishOffsideOp = function (op) ::\n  let pos0 = this.state.pos\n  if (op.extraChars)\n    this.state.pos += op.extraChars\n\n  this.finishToken(tt_offside[op.tokenPre])\n  if (this.isLookahead) return\n\n  let stack = this.state.offside\n  let stackTop = stack[stack.length - 1]\n  let blk = this.offsideBlock(op, stackTop)\n  this.state.offside.push(blk)\n\n\npp.skipSpace = function() ::\n  let stackTop, stack = this.state.offside\n  if (stack && stack.length) ::\n    stackTop = stack[stack.length-1]\n    this.state.offsidePos = stackTop.last.posLastContent\n  else this.state.offsidePos = -1\n\n  try ::\n    baseProto.skipSpace.call(this)\n    this.state.offsidePos = -1\n  catch (err) ::\n    if (err !== offsideBreakout) throw err;\n\n\npp.readToken = function(code) ::\n  if (this.state.pos !== this.state.offsidePos)\n    return baseProto.readToken.call(this, code)\n\n  return this.popOffside()\n\npp.popOffside = function() ::\n  let stack = this.state.offside\n  let stackTop = this.isLookahead\n    ? stack[stack.length-1]\n    : stack.pop()\n  this.state.offsidePos = -1\n\n  let tt_post = tt_offside[stackTop.op.tokenPost]\n  this.finishToken(tt_post)\n  return tt_post\n\n\n\nconst rx_offside = /^([ \\t]*)(.*)$/mg\nfunction parseOffsideIndexMap(input) ::\n  let lines = [null], posLastContent=0, last=['', 0]\n\n  let ans = input.replace @ rx_offside, (match, indent, content, pos) => ::\n    if (!content) ::\n      [indent, posLastContent] = last // blank line; use last valid content as end\n    else ::\n      // valid content; set last to current indent\n      posLastContent = pos + match.length\n      last = [indent, posLastContent]\n\n    lines.push({line: lines.length, posLastContent, indent, content})\n    return ''\n\n  return lines\n\n\n\nmodule.exports = exports = (babel) => @\n  @{}\n    manipulateOptions(opts, parserOpts) ::\n      parserOpts.plugins.push('decorators', 'functionBind')\n\n\nObject.assign @ exports,\n  @{}\n    hookBabylon,\n    parseOffsideIndexMap,\n\n"]}