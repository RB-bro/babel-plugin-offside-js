{"version":3,"sources":["../index.js"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["'use strict'\nconst assert = require('assert')\nconst babylon = require('babylon')\nconst tt = babylon.tokTypes\n\nconst Parser = hookBabylon()\nconst baseProto = Parser.prototype\nconst pp = Parser.prototype = Object.create(baseProto)\n\nfunction hookBabylon() ::\n  // abuse Babylon token updateContext callback extract\n  // the reference to Parser\n\n  let Parser\n  let tgt_patch = babylon.tokTypes.braceL\n  let fn_updateContext = tgt_patch.updateContext\n  tgt_patch.updateContext = function (prevType) ::\n    tgt_patch.updateContext = fn_updateContext\n    Parser = this.constructor\n\n  babylon.parse('{}')\n  if (!Parser)\n    throw new Error @ \"Failed to hook Babylon Parser\"\n  return Parser\n\n\n\npp.parse = function() ::\n  this.initOffside()\n  return baseProto.parse.call(this)\n\n\nclass OffsideBreakout extends Error {}\nconst offsideBreakout = new OffsideBreakout()\n\npp.initOffside = function() ::\n  this.state.offside = []\n  this.offside_lines = parseOffsideIndexMap(this.input)\n\n  this.state._pos = this.state.pos\n  Object.defineProperty @ this.state, 'pos', ::\n    enumerable: true\n    , get() :: return this._pos\n    , set(pos) ::\n      // interrupt skipSpace algorithm when we hit our position 'breakpoint'\n      let offPos = this.offsidePos\n      if (offPos>=0 && (pos > offPos))\n        throw offsideBreakout\n\n      this._pos = pos\n\n\nlet tt_offside =\n  @{} '{': tt.braceL,   '}': tt.braceR\n    , '(': tt.parenL,   ')': tt.parenR\n    , '[': tt.bracketL, ']': tt.bracketR\n\nlet at_offside =\n  @{} '::':  {tokenPre: '{', tokenPost: '}', nestInner: false}\n    , '@':   {tokenPre: '(', tokenPost: ')', nestInner: true}\n    , '@{}': {tokenPre: '{', tokenPost: '}', nestInner: true, extraChars: 2}\n    , '@[]': {tokenPre: '[', tokenPost: ']', nestInner: true, extraChars: 2}\n    // note: no '@()' -- standardize to use single-char '@ ' instead\n\npp.finishToken = function(type, val) ::\n  let op\n  if (tt.doubleColon === type) ::\n    return this.finishOffsideOp(at_offside['::'])\n\n  if (tt.at === type) ::\n    const str_op = this.input.slice(this.state.pos-1, this.state.pos+2)\n\n    if (/^@\\s/.test(str_op)) ::\n      return this.finishOffsideOp(at_offside['@'])\n\n    op = at_offside[str_op.slice(0,2)]\n    if (op) return this.finishOffsideOp(op)\n\n    op = at_offside[str_op]\n    if (op) return this.finishOffsideOp(op)\n\n\n  if (tt.eof === type) ::\n    if (this.state.offside.length) ::\n      return this.popOffside()\n\n\n  return baseProto.finishToken.call(this, type, val)\n\n\n\npp.offsideBlock = function (op, stackTop) ::\n  let offside_lines = this.offside_lines\n\n  const line0 = this.state.curLine\n  const first = offside_lines[line0]\n  const nestInner = op.nestInner && stackTop && line0 === stackTop.first.line\n  const indent = nestInner ? stackTop.innerIndent : first.indent\n  let line = 1+line0, last = first\n  let innerIndent = offside_lines[line].indent\n\n  while (line < offside_lines.length) ::\n    let cur = offside_lines[line]\n    if (cur.content && indent >= cur.indent) ::\n      break\n\n    line++; last = cur\n    if (innerIndent > cur.indent) ::\n      innerIndent = cur.indent\n\n  // cap to \n  innerIndent = first.indent > innerIndent\n    ? first.indent : innerIndent\n\n  return {op, innerIndent, first, last, nestInner}\n\n\npp.finishOffsideOp = function (op) ::\n  let pos0 = this.state.pos\n  if (op.extraChars)\n    this.state.pos += op.extraChars\n\n  this.finishToken(tt_offside[op.tokenPre])\n  if (this.isLookahead) return\n\n  let stack = this.state.offside\n  let stackTop = stack[stack.length - 1]\n  let blk = this.offsideBlock(op, stackTop)\n  this.state.offside.push(blk)\n\n\npp.skipSpace = function() ::\n  let stackTop, stack = this.state.offside\n  if (stack && stack.length) ::\n    stackTop = stack[stack.length-1]\n    this.state.offsidePos = stackTop.last.posLastContent\n  else this.state.offsidePos = -1\n\n  try ::\n    baseProto.skipSpace.call(this)\n    this.state.offsidePos = -1\n  catch (err) ::\n    if (err !== offsideBreakout) throw err;\n\n\npp.readToken = function(code) ::\n  if (this.state.pos !== this.state.offsidePos)\n    return baseProto.readToken.call(this, code)\n\n  return this.popOffside()\n\npp.popOffside = function() ::\n  let stack = this.state.offside\n  let stackTop = this.isLookahead\n    ? stack[stack.length-1]\n    : stack.pop()\n  this.state.offsidePos = -1\n\n  let tt_post = tt_offside[stackTop.op.tokenPost]\n  this.finishToken(tt_post)\n  return tt_post\n\n\n\nconst rx_offside = /^([ \\t]*)(.*)$/mg\nfunction parseOffsideIndexMap(input) ::\n  let lines = [null], posLastContent=0, last=['', 0]\n\n  let ans = input.replace @ rx_offside, (match, indent, content, pos) => ::\n    if (!content) ::\n      [indent, posLastContent] = last // blank line; use last valid content as end\n    else ::\n      // valid content; set last to current indent\n      posLastContent = pos + match.length\n      last = [indent, posLastContent]\n\n    lines.push({line: lines.length, posLastContent, indent, content})\n    return ''\n\n  return lines\n\n\n\nmodule.exports = exports = (babel) => @\n  @{}\n    manipulateOptions(opts, parserOpts) ::\n      parserOpts.plugins.push('decorators', 'functionBind')\n\n\nObject.assign @ exports,\n  @{}\n    hookBabylon,\n    parseOffsideIndexMap,\n\n"]}