const babylon = require('babylon');
const tt = babylon.tokTypes;

var _g_offsidePluginOpts;
const default_offsidePluginOpts = { keyword_blocks: true };

const _base_module_parse = babylon.parse;
babylon.parse = (input, options) => {
  _g_offsidePluginOpts = options ? options.offsidePluginOpts : undefined;
  return _base_module_parse(input, options);
};

const Parser = hookBabylon();
const baseProto = Parser.prototype;
const pp = Parser.prototype = Object.create(baseProto);

function hookBabylon() {
  // abuse Babylon token updateContext callback extract
  // the reference to Parser

  let Parser;
  let tgt_patch = babylon.tokTypes.braceL;
  let fn_updateContext = tgt_patch.updateContext;
  tgt_patch.updateContext = function (prevType) {
    tgt_patch.updateContext = fn_updateContext;
    Parser = this.constructor;
  };

  babylon.parse('{}');
  if (!Parser) {
    throw new Error("Failed to hook Babylon Parser");
  }
  return Parser;
}

pp._base_parse = baseProto.parse;
pp.parse = function () {
  this.initOffside();
  return this._base_parse();
};

class OffsideBreakout extends Error {}
const offsideBreakout = new OffsideBreakout();

pp.initOffside = function () {
  this.state.offside = [];
  this.state.offsideNextOp = null;
  this.offside_lines = parseOffsideIndexMap(this.input);
  this.offsidePluginOpts = _g_offsidePluginOpts || {};
  _g_offsidePluginOpts = null;

  this.state._pos = this.state.pos;
  Object.defineProperty(this.state, 'pos', { enumerable: true,
    get() {
      return this._pos;
    }, set(pos) {
      // interrupt skipSpace algorithm when we hit our position 'breakpoint'
      let offPos = this.offsidePos;
      if (offPos >= 0 && pos > offPos) {
        throw offsideBreakout;
      }

      this._pos = pos;
    } });
};

let tt_offside_keyword_with_args = new Set([tt._if, tt._while, tt._for, tt._catch, tt._switch]);

let tt_offside_keyword_lookahead_skip = new Set([tt.parenL, tt.colon, tt.comma, tt.dot]);

let at_offside = { '::': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: false, codeBlock: true },
  '::@': { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: false, extraChars: 1 },
  '::()': { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: false, extraChars: 2 },
  '::{}': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: false, extraChars: 2 },
  '::[]': { tokenPre: tt.bracketL, tokenPost: tt.bracketR, nestInner: false, extraChars: 2 },
  '@': { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: true, keywordBlock: true },
  '@()': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: true, extraChars: 2 },
  '@{}': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: true, extraChars: 2 },
  '@[]': { tokenPre: tt.bracketL, tokenPost: tt.bracketR, nestInner: true, extraChars: 2 }
  // note:  no '@()' -- standardize to use single-char '@ ' instead
  , keyword_args: { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: false, inKeywordArg: true } };

pp._base_finishToken = baseProto.finishToken;
pp.finishToken = function (type, val) {
  const state = this.state;

  if (tt_offside_keyword_with_args.has(type)) {
    let isKeywordAllowed = !this.isLookahead && tt.dot !== state.type;

    state.offsideRecentKeyword = isKeywordAllowed;
    if (!isKeywordAllowed) {
      return this._base_finishToken(type, val);
    }

    const lookahead = this.lookahead();

    if (!tt_offside_keyword_lookahead_skip.has(lookahead.type)) {
      state.offsideNextOp = at_offside.keyword_args;
    }

    return this._base_finishToken(type, val);
  }

  const recentKeyword = state.offsideRecentKeyword;
  state.offsideRecentKeyword = null;
  if (type === tt.at || type === tt.doubleColon) {
    const pos0 = state.start,
          pos1 = state.pos + 2;
    const str_op = this.input.slice(pos0, pos1).split(/\s/, 1)[0];

    let op = at_offside[str_op];
    if (op.keywordBlock && recentKeyword && tt_offside_keyword_with_args.has(state.type)) {
      op = at_offside.keyword_args;
    }
    if (op) {
      return this.finishOffsideOp(op);
    }
  }

  if (tt.eof === type) {
    if (state.offside.length) {
      return this.popOffside();
    }
  }

  return this._base_finishToken(type, val);
};

pp.offsideBlock = function (op, stackTop) {
  let offside_lines = this.offside_lines;

  const line0 = this.state.curLine;
  const first = offside_lines[line0];
  const nestInner = op.nestInner && stackTop && line0 === stackTop.first.line;
  const indent = nestInner ? stackTop.innerIndent : first.indent;
  let line = 1 + line0,
      last = first;
  const innerLine = offside_lines[line];
  let innerIndent = innerLine ? innerLine.indent : '';

  while (line < offside_lines.length) {
    let cur = offside_lines[line];
    if (cur.content && indent >= cur.indent) {
      break;
    }

    line++;last = cur;
    if (innerIndent > cur.indent) {
      innerIndent = cur.indent;
    }
  }

  // cap to 
  innerIndent = first.indent > innerIndent ? first.indent : innerIndent;

  return { op, innerIndent, first, last, nestInner };
};

pp.finishOffsideOp = function (op) {
  const stack = this.state.offside;
  let stackTop = stack[stack.length - 1];
  if (stackTop && stackTop.inKeywordArg && op.codeBlock) {
    this.popOffside();
    this.state.offsideNextOp = op;
    return;
  }

  if (op.extraChars) {
    this.state.pos += op.extraChars;
  }

  this._base_finishToken(op.tokenPre);

  if (this.isLookahead) {
    return;
  }

  stackTop = stack[stack.length - 1];
  let blk = this.offsideBlock(op, stackTop);
  blk.inKeywordArg = op.inKeywordArg || stackTop && stackTop.inKeywordArg;
  this.state.offside.push(blk);
};

pp._base_skipSpace = baseProto.skipSpace;
pp.skipSpace = function () {
  if (null !== this.state.offsideNextOp) {
    return;
  }

  const stack = this.state.offside;
  let stackTop;
  if (stack && stack.length) {
    stackTop = stack[stack.length - 1];
    this.state.offsidePos = stackTop.last.posLastContent;
  } else {
    this.state.offsidePos = -1;
  }

  try {
    this._base_skipSpace();
    this.state.offsidePos = -1;
  } catch (err) {
    if (err !== offsideBreakout) {
      throw err;
    }
  }
};

pp._base_readToken = baseProto.readToken;
pp.readToken = function (code) {
  const offsideNextOp = this.state.offsideNextOp;
  if (null !== offsideNextOp) {
    this.state.offsideNextOp = null;
    return this.finishOffsideOp(offsideNextOp);
  } else if (this.state.pos === this.state.offsidePos) {
    return this.popOffside();
  } else {
    return this._base_readToken(code);
  }
};

pp.popOffside = function () {
  const stack = this.state.offside;
  let stackTop = this.isLookahead ? stack[stack.length - 1] : stack.pop();
  this.state.offsidePos = -1;

  this._base_finishToken(stackTop.op.tokenPost);
  return stackTop;
};

const rx_offside = /^([ \t]*)(.*)$/mg;
function parseOffsideIndexMap(input) {
  let lines = [null],
      posLastContent = 0,
      last = ['', 0];

  let ans = input.replace(rx_offside, (match, indent, content, pos) => {
    if (!content) {
      [indent, posLastContent] = last; // blank line; use last valid content as end
    } else {
        // valid content; set last to current indent
        posLastContent = pos + match.length;
        last = [indent, posLastContent];
      }

    lines.push({ line: lines.length, posLastContent, indent, content });
    return '';
  });

  return lines;
}

const keyword_block_parents = { IfStatement: 'if',
  ForStatement: 'for',
  ForOfStatement: 'for',
  WhileStatement: 'while',
  DoWhileStatement: 'do-while' };
const lint_keyword_block_parents = new Set(Object.keys(keyword_block_parents));

const babel_plugin_id = `babel-plugin-offside--${Date.now()}`;
module.exports = exports = babel => {
  return {
    name: babel_plugin_id,
    pre(state) {
      this.opts = Object.assign({}, default_offsidePluginOpts, this.opts);
    }, manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push('decorators', 'functionBind');
      const offsidePluginOpts = opts.plugins.filter(plugin => plugin[0] && babel_plugin_id === plugin[0].key && plugin[1]).map(plugin => plugin[1]).pop();
      parserOpts.offsidePluginOpts = offsidePluginOpts || default_offsidePluginOpts;
    }, visitor: {
      ExpressionStatement(path) {
        if (!this.opts.keyword_blocks) {
          return;
        }
        if (!lint_keyword_block_parents.has(path.parent.type)) {
          return;
        }

        let keyword = keyword_block_parents[path.parent.type];
        if ('if' === keyword && path.node === path.parent.alternate) {
          keyword = 'else'; // fixup if/else combined parent condition
        }throw path.buildCodeFrameError(`Keyword '${keyword}' should be followed by a block statement using '::' or matching '{' / '}'. \n` + `    (From 'keyword_blocks' enforcement option of babel-plugin-offside)`);
      } } };
};

Object.assign(exports, {
  hookBabylon,
  parseOffsideIndexMap });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2NvZGUvaW5kZXguanMiXSwibmFtZXMiOlsiYmFieWxvbiIsInJlcXVpcmUiLCJ0dCIsInRva1R5cGVzIiwiX2dfb2Zmc2lkZVBsdWdpbk9wdHMiLCJkZWZhdWx0X29mZnNpZGVQbHVnaW5PcHRzIiwia2V5d29yZF9ibG9ja3MiLCJfYmFzZV9tb2R1bGVfcGFyc2UiLCJwYXJzZSIsImlucHV0Iiwib3B0aW9ucyIsIm9mZnNpZGVQbHVnaW5PcHRzIiwidW5kZWZpbmVkIiwiUGFyc2VyIiwiaG9va0JhYnlsb24iLCJiYXNlUHJvdG8iLCJwcm90b3R5cGUiLCJwcCIsIk9iamVjdCIsImNyZWF0ZSIsInRndF9wYXRjaCIsImJyYWNlTCIsImZuX3VwZGF0ZUNvbnRleHQiLCJ1cGRhdGVDb250ZXh0IiwicHJldlR5cGUiLCJjb25zdHJ1Y3RvciIsIkVycm9yIiwiX2Jhc2VfcGFyc2UiLCJpbml0T2Zmc2lkZSIsIk9mZnNpZGVCcmVha291dCIsIm9mZnNpZGVCcmVha291dCIsInN0YXRlIiwib2Zmc2lkZSIsIm9mZnNpZGVOZXh0T3AiLCJvZmZzaWRlX2xpbmVzIiwicGFyc2VPZmZzaWRlSW5kZXhNYXAiLCJfcG9zIiwicG9zIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2V0Iiwib2ZmUG9zIiwib2Zmc2lkZVBvcyIsInR0X29mZnNpZGVfa2V5d29yZF93aXRoX2FyZ3MiLCJTZXQiLCJfaWYiLCJfd2hpbGUiLCJfZm9yIiwiX2NhdGNoIiwiX3N3aXRjaCIsInR0X29mZnNpZGVfa2V5d29yZF9sb29rYWhlYWRfc2tpcCIsInBhcmVuTCIsImNvbG9uIiwiY29tbWEiLCJkb3QiLCJhdF9vZmZzaWRlIiwidG9rZW5QcmUiLCJ0b2tlblBvc3QiLCJicmFjZVIiLCJuZXN0SW5uZXIiLCJjb2RlQmxvY2siLCJwYXJlblIiLCJleHRyYUNoYXJzIiwiYnJhY2tldEwiLCJicmFja2V0UiIsImtleXdvcmRCbG9jayIsImtleXdvcmRfYXJncyIsImluS2V5d29yZEFyZyIsIl9iYXNlX2ZpbmlzaFRva2VuIiwiZmluaXNoVG9rZW4iLCJ0eXBlIiwidmFsIiwiaGFzIiwiaXNLZXl3b3JkQWxsb3dlZCIsImlzTG9va2FoZWFkIiwib2Zmc2lkZVJlY2VudEtleXdvcmQiLCJsb29rYWhlYWQiLCJyZWNlbnRLZXl3b3JkIiwiYXQiLCJkb3VibGVDb2xvbiIsInBvczAiLCJzdGFydCIsInBvczEiLCJzdHJfb3AiLCJzbGljZSIsInNwbGl0Iiwib3AiLCJmaW5pc2hPZmZzaWRlT3AiLCJlb2YiLCJsZW5ndGgiLCJwb3BPZmZzaWRlIiwib2Zmc2lkZUJsb2NrIiwic3RhY2tUb3AiLCJsaW5lMCIsImN1ckxpbmUiLCJmaXJzdCIsImxpbmUiLCJpbmRlbnQiLCJpbm5lckluZGVudCIsImxhc3QiLCJpbm5lckxpbmUiLCJjdXIiLCJjb250ZW50Iiwic3RhY2siLCJibGsiLCJwdXNoIiwiX2Jhc2Vfc2tpcFNwYWNlIiwic2tpcFNwYWNlIiwicG9zTGFzdENvbnRlbnQiLCJlcnIiLCJfYmFzZV9yZWFkVG9rZW4iLCJyZWFkVG9rZW4iLCJjb2RlIiwicG9wIiwicnhfb2Zmc2lkZSIsImxpbmVzIiwiYW5zIiwicmVwbGFjZSIsIm1hdGNoIiwia2V5d29yZF9ibG9ja19wYXJlbnRzIiwiSWZTdGF0ZW1lbnQiLCJGb3JTdGF0ZW1lbnQiLCJGb3JPZlN0YXRlbWVudCIsIldoaWxlU3RhdGVtZW50IiwiRG9XaGlsZVN0YXRlbWVudCIsImxpbnRfa2V5d29yZF9ibG9ja19wYXJlbnRzIiwia2V5cyIsImJhYmVsX3BsdWdpbl9pZCIsIkRhdGUiLCJub3ciLCJtb2R1bGUiLCJleHBvcnRzIiwiYmFiZWwiLCJuYW1lIiwicHJlIiwib3B0cyIsImFzc2lnbiIsIm1hbmlwdWxhdGVPcHRpb25zIiwicGFyc2VyT3B0cyIsInBsdWdpbnMiLCJmaWx0ZXIiLCJwbHVnaW4iLCJrZXkiLCJtYXAiLCJ2aXNpdG9yIiwiRXhwcmVzc2lvblN0YXRlbWVudCIsInBhdGgiLCJwYXJlbnQiLCJr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aUJBQVdDLE9BQVgsQ0FBbUJsQyxJQUFuQixDQUF3QixZQUF4QixFQUFzQyxjQUF0QztBQUNBLFlBQU0vRixvQkFBb0I2SCxLQUFLSSxPQUFMLENBQ3ZCQyxNQUR1QixDQUNkQyxVQUFVQSxPQUFPLENBQVAsS0FBYWQsb0JBQW9CYyxPQUFPLENBQVAsRUFBVUMsR0FBM0MsSUFBa0RELE9BQU8sQ0FBUCxDQUQ5QyxFQUV2QkUsR0FGdUIsQ0FFakJGLFVBQVVBLE9BQU8sQ0FBUCxDQUZPLEVBR3ZCNUIsR0FIdUIsRUFBMUI7QUFJQXlCLGlCQUFXaEksaUJBQVgsR0FBK0JBLHFCQUFxQk4seUJBQXBEO0FBQTZFLEtBWDVFLEVBYUg0SSxTQUFTO0FBQ1BDLDBCQUFvQkMsSUFBcEIsRUFBMEI7QUFDeEIsWUFBSSxDQUFDLEtBQUtYLElBQUwsQ0FBVWxJLGNBQWYsRUFBK0I7QUFBRztBQUFNO0FBQ3hDLFlBQUksQ0FBQ3dILDJCQUEyQnJELEdBQTNCLENBQStCMEUsS0FBS0MsTUFBTCxDQUFZN0UsSUFBM0MsQ0FBTCxFQUF1RDtBQUFHO0FBQU07O0FBRWhFLFlBQUk4RSxVQUFVN0Isc0JBQXNCMkIsS0FBS0MsTUFBTCxDQUFZN0UsSUFBbEMsQ0FBZDtBQUNBLFlBQUksU0FBUzhFLE9BQVQsSUFBb0JGLEtBQUtHLElBQUwsS0FBY0gsS0FBS0MsTUFBTCxDQUFZRyxTQUFsRCxFQUE2RDtBQUMzREYsb0JBQVUsTUFBVixDQUQyRCxDQUMxQztBQUEwQyxTQUU3RCxNQUFNRixLQUFLSyxtQkFBTCxDQUNILFlBQVdILE9BQVEsZ0ZBQXBCLEdBQ0Msd0VBRkcsQ0FBTjtBQUUwRSxPQVhyRSxFQWJOLEVBQVA7QUF3QmtGLENBekJwRjs7QUE0QkFuSSxPQUFPdUgsTUFBUCxDQUFnQkwsT0FBaEIsRUFDRTtBQUNFdEgsYUFERjtBQUVFcUIsc0JBRkYsRUFERiIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGJhYnlsb24gPSByZXF1aXJlKCdiYWJ5bG9uJylcbmNvbnN0IHR0ID0gYmFieWxvbi50b2tUeXBlc1xuXG52YXIgX2dfb2Zmc2lkZVBsdWdpbk9wdHNcbmNvbnN0IGRlZmF1bHRfb2Zmc2lkZVBsdWdpbk9wdHMgPVxuICBAe30ga2V5d29yZF9ibG9ja3M6IHRydWVcblxuY29uc3QgX2Jhc2VfbW9kdWxlX3BhcnNlID0gYmFieWxvbi5wYXJzZVxuYmFieWxvbi5wYXJzZSA9IChpbnB1dCwgb3B0aW9ucykgPT4gOjpcbiAgX2dfb2Zmc2lkZVBsdWdpbk9wdHMgPSBvcHRpb25zID8gb3B0aW9ucy5vZmZzaWRlUGx1Z2luT3B0cyA6IHVuZGVmaW5lZFxuICByZXR1cm4gX2Jhc2VfbW9kdWxlX3BhcnNlKGlucHV0LCBvcHRpb25zKVxuXG5jb25zdCBQYXJzZXIgPSBob29rQmFieWxvbigpXG5jb25zdCBiYXNlUHJvdG8gPSBQYXJzZXIucHJvdG90eXBlXG5jb25zdCBwcCA9IFBhcnNlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm90bylcblxuZnVuY3Rpb24gaG9va0JhYnlsb24oKSA6OlxuICAvLyBhYnVzZSBCYWJ5bG9uIHRva2VuIHVwZGF0ZUNvbnRleHQgY2FsbGJhY2sgZXh0cmFjdFxuICAvLyB0aGUgcmVmZXJlbmNlIHRvIFBhcnNlclxuXG4gIGxldCBQYXJzZXJcbiAgbGV0IHRndF9wYXRjaCA9IGJhYnlsb24udG9rVHlwZXMuYnJhY2VMXG4gIGxldCBmbl91cGRhdGVDb250ZXh0ID0gdGd0X3BhdGNoLnVwZGF0ZUNvbnRleHRcbiAgdGd0X3BhdGNoLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAocHJldlR5cGUpIDo6XG4gICAgdGd0X3BhdGNoLnVwZGF0ZUNvbnRleHQgPSBmbl91cGRhdGVDb250ZXh0XG4gICAgUGFyc2VyID0gdGhpcy5jb25zdHJ1Y3RvclxuXG4gIGJhYnlsb24ucGFyc2UoJ3t9JylcbiAgaWYgKCFQYXJzZXIpIDo6XG4gICAgdGhyb3cgbmV3IEVycm9yIEAgXCJGYWlsZWQgdG8gaG9vayBCYWJ5bG9uIFBhcnNlclwiXG4gIHJldHVybiBQYXJzZXJcblxuXG5cbnBwLl9iYXNlX3BhcnNlID0gYmFzZVByb3RvLnBhcnNlXG5wcC5wYXJzZSA9IGZ1bmN0aW9uKCkgOjpcbiAgdGhpcy5pbml0T2Zmc2lkZSgpXG4gIHJldHVybiB0aGlzLl9iYXNlX3BhcnNlKClcblxuXG5jbGFzcyBPZmZzaWRlQnJlYWtvdXQgZXh0ZW5kcyBFcnJvciB7fVxuY29uc3Qgb2Zmc2lkZUJyZWFrb3V0ID0gbmV3IE9mZnNpZGVCcmVha291dCgpXG5cbnBwLmluaXRPZmZzaWRlID0gZnVuY3Rpb24oKSA6OlxuICB0aGlzLnN0YXRlLm9mZnNpZGUgPSBbXVxuICB0aGlzLnN0YXRlLm9mZnNpZGVOZXh0T3AgPSBudWxsXG4gIHRoaXMub2Zmc2lkZV9saW5lcyA9IHBhcnNlT2Zmc2lkZUluZGV4TWFwKHRoaXMuaW5wdXQpXG4gIHRoaXMub2Zmc2lkZVBsdWdpbk9wdHMgPSBfZ19vZmZzaWRlUGx1Z2luT3B0cyB8fCB7fVxuICBfZ19vZmZzaWRlUGx1Z2luT3B0cyA9IG51bGxcblxuICB0aGlzLnN0YXRlLl9wb3MgPSB0aGlzLnN0YXRlLnBvc1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkgQCB0aGlzLnN0YXRlLCAncG9zJyxcbiAgICBAe30gZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgLCBnZXQoKSA6OiByZXR1cm4gdGhpcy5fcG9zXG4gICAgICAsIHNldChwb3MpIDo6XG4gICAgICAgICAgLy8gaW50ZXJydXB0IHNraXBTcGFjZSBhbGdvcml0aG0gd2hlbiB3ZSBoaXQgb3VyIHBvc2l0aW9uICdicmVha3BvaW50J1xuICAgICAgICAgIGxldCBvZmZQb3MgPSB0aGlzLm9mZnNpZGVQb3NcbiAgICAgICAgICBpZiAob2ZmUG9zPj0wICYmIChwb3MgPiBvZmZQb3MpKSA6OlxuICAgICAgICAgICAgdGhyb3cgb2Zmc2lkZUJyZWFrb3V0XG5cbiAgICAgICAgICB0aGlzLl9wb3MgPSBwb3NcblxuXG5sZXQgdHRfb2Zmc2lkZV9rZXl3b3JkX3dpdGhfYXJncyA9IG5ldyBTZXQgQFxuICBAW10gdHQuX2lmLCB0dC5fd2hpbGUsIHR0Ll9mb3JcbiAgICAsIHR0Ll9jYXRjaCwgdHQuX3N3aXRjaFxuXG5sZXQgdHRfb2Zmc2lkZV9rZXl3b3JkX2xvb2thaGVhZF9za2lwID0gbmV3IFNldCBAXG4gIEBbXSB0dC5wYXJlbkwsIHR0LmNvbG9uLCB0dC5jb21tYSwgdHQuZG90XG5cbmxldCBhdF9vZmZzaWRlID1cbiAgQHt9ICc6Oic6ICAge3Rva2VuUHJlOiB0dC5icmFjZUwsIHRva2VuUG9zdDogdHQuYnJhY2VSLCBuZXN0SW5uZXI6IGZhbHNlLCBjb2RlQmxvY2s6IHRydWV9XG4gICAgLCAnOjpAJzogIHt0b2tlblByZTogdHQucGFyZW5MLCB0b2tlblBvc3Q6IHR0LnBhcmVuUiwgbmVzdElubmVyOiBmYWxzZSwgZXh0cmFDaGFyczogMX1cbiAgICAsICc6OigpJzoge3Rva2VuUHJlOiB0dC5wYXJlbkwsIHRva2VuUG9zdDogdHQucGFyZW5SLCBuZXN0SW5uZXI6IGZhbHNlLCBleHRyYUNoYXJzOiAyfVxuICAgICwgJzo6e30nOiB7dG9rZW5QcmU6IHR0LmJyYWNlTCwgdG9rZW5Qb3N0OiB0dC5icmFjZVIsIG5lc3RJbm5lcjogZmFsc2UsIGV4dHJhQ2hhcnM6IDJ9XG4gICAgLCAnOjpbXSc6IHt0b2tlblByZTogdHQuYnJhY2tldEwsIHRva2VuUG9zdDogdHQuYnJhY2tldFIsIG5lc3RJbm5lcjogZmFsc2UsIGV4dHJhQ2hhcnM6IDJ9XG4gICAgLCAnQCc6ICAgIHt0b2tlblByZTogdHQucGFyZW5MLCB0b2tlblBvc3Q6IHR0LnBhcmVuUiwgbmVzdElubmVyOiB0cnVlLCBrZXl3b3JkQmxvY2s6IHRydWV9XG4gICAgLCAnQCgpJzogIHt0b2tlblByZTogdHQuYnJhY2VMLCB0b2tlblBvc3Q6IHR0LmJyYWNlUiwgbmVzdElubmVyOiB0cnVlLCBleHRyYUNoYXJzOiAyfVxuICAgICwgJ0B7fSc6ICB7dG9rZW5QcmU6IHR0LmJyYWNlTCwgdG9rZW5Qb3N0OiB0dC5icmFjZVIsIG5lc3RJbm5lcjogdHJ1ZSwgZXh0cmFDaGFyczogMn1cbiAgICAsICdAW10nOiAge3Rva2VuUHJlOiB0dC5icmFja2V0TCwgdG9rZW5Qb3N0OiB0dC5icmFja2V0UiwgbmVzdElubmVyOiB0cnVlLCBleHRyYUNoYXJzOiAyfVxuICAgIC8vIG5vdGU6ICBubyAnQCgpJyAtLSBzdGFuZGFyZGl6ZSB0byB1c2Ugc2luZ2xlLWNoYXIgJ0AgJyBpbnN0ZWFkXG4gICAgLCBrZXl3b3JkX2FyZ3M6IHt0b2tlblByZTogdHQucGFyZW5MLCB0b2tlblBvc3Q6IHR0LnBhcmVuUiwgbmVzdElubmVyOiBmYWxzZSwgaW5LZXl3b3JkQXJnOiB0cnVlfVxuXG5wcC5fYmFzZV9maW5pc2hUb2tlbiA9IGJhc2VQcm90by5maW5pc2hUb2tlblxucHAuZmluaXNoVG9rZW4gPSBmdW5jdGlvbih0eXBlLCB2YWwpIDo6XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZVxuXG4gIGlmICh0dF9vZmZzaWRlX2tleXdvcmRfd2l0aF9hcmdzLmhhcyh0eXBlKSkgOjpcbiAgICBsZXQgaXNLZXl3b3JkQWxsb3dlZCA9ICF0aGlzLmlzTG9va2FoZWFkXG4gICAgICAmJiB0dC5kb3QgIT09IHN0YXRlLnR5cGVcblxuICAgIHN0YXRlLm9mZnNpZGVSZWNlbnRLZXl3b3JkID0gaXNLZXl3b3JkQWxsb3dlZFxuICAgIGlmICghaXNLZXl3b3JkQWxsb3dlZCkgOjpcbiAgICAgIHJldHVybiB0aGlzLl9iYXNlX2ZpbmlzaFRva2VuKHR5cGUsIHZhbClcblxuICAgIGNvbnN0IGxvb2thaGVhZCA9IHRoaXMubG9va2FoZWFkKClcblxuICAgIGlmICghdHRfb2Zmc2lkZV9rZXl3b3JkX2xvb2thaGVhZF9za2lwLmhhcyhsb29rYWhlYWQudHlwZSkpIDo6XG4gICAgICBzdGF0ZS5vZmZzaWRlTmV4dE9wID0gYXRfb2Zmc2lkZS5rZXl3b3JkX2FyZ3NcblxuICAgIHJldHVybiB0aGlzLl9iYXNlX2ZpbmlzaFRva2VuKHR5cGUsIHZhbClcblxuICBjb25zdCByZWNlbnRLZXl3b3JkID0gc3RhdGUub2Zmc2lkZVJlY2VudEtleXdvcmRcbiAgc3RhdGUub2Zmc2lkZVJlY2VudEtleXdvcmQgPSBudWxsXG4gIGlmICh0eXBlID09PSB0dC5hdCB8fCB0eXBlID09PSB0dC5kb3VibGVDb2xvbikgOjpcbiAgICBjb25zdCBwb3MwID0gc3RhdGUuc3RhcnQsIHBvczEgPSBzdGF0ZS5wb3MgKyAyXG4gICAgY29uc3Qgc3RyX29wID0gdGhpcy5pbnB1dC5zbGljZShwb3MwLCBwb3MxKS5zcGxpdCgvXFxzLywgMSlbMF1cblxuICAgIGxldCBvcCA9IGF0X29mZnNpZGVbc3RyX29wXVxuICAgIGlmIChvcC5rZXl3b3JkQmxvY2sgJiYgcmVjZW50S2V5d29yZCAmJiB0dF9vZmZzaWRlX2tleXdvcmRfd2l0aF9hcmdzLmhhcyhzdGF0ZS50eXBlKSkgOjpcbiAgICAgIG9wID0gYXRfb2Zmc2lkZS5rZXl3b3JkX2FyZ3NcbiAgICBpZiAob3ApIDo6IHJldHVybiB0aGlzLmZpbmlzaE9mZnNpZGVPcChvcClcblxuICBpZiAodHQuZW9mID09PSB0eXBlKSA6OlxuICAgIGlmIChzdGF0ZS5vZmZzaWRlLmxlbmd0aCkgOjpcbiAgICAgIHJldHVybiB0aGlzLnBvcE9mZnNpZGUoKVxuXG4gIHJldHVybiB0aGlzLl9iYXNlX2ZpbmlzaFRva2VuKHR5cGUsIHZhbClcblxuXG5cbnBwLm9mZnNpZGVCbG9jayA9IGZ1bmN0aW9uIChvcCwgc3RhY2tUb3ApIDo6XG4gIGxldCBvZmZzaWRlX2xpbmVzID0gdGhpcy5vZmZzaWRlX2xpbmVzXG5cbiAgY29uc3QgbGluZTAgPSB0aGlzLnN0YXRlLmN1ckxpbmVcbiAgY29uc3QgZmlyc3QgPSBvZmZzaWRlX2xpbmVzW2xpbmUwXVxuICBjb25zdCBuZXN0SW5uZXIgPSBvcC5uZXN0SW5uZXIgJiYgc3RhY2tUb3AgJiYgbGluZTAgPT09IHN0YWNrVG9wLmZpcnN0LmxpbmVcbiAgY29uc3QgaW5kZW50ID0gbmVzdElubmVyID8gc3RhY2tUb3AuaW5uZXJJbmRlbnQgOiBmaXJzdC5pbmRlbnRcbiAgbGV0IGxpbmUgPSAxK2xpbmUwLCBsYXN0ID0gZmlyc3RcbiAgY29uc3QgaW5uZXJMaW5lID0gb2Zmc2lkZV9saW5lc1tsaW5lXVxuICBsZXQgaW5uZXJJbmRlbnQgPSBpbm5lckxpbmUgPyBpbm5lckxpbmUuaW5kZW50IDogJydcblxuICB3aGlsZSAobGluZSA8IG9mZnNpZGVfbGluZXMubGVuZ3RoKSA6OlxuICAgIGxldCBjdXIgPSBvZmZzaWRlX2xpbmVzW2xpbmVdXG4gICAgaWYgKGN1ci5jb250ZW50ICYmIGluZGVudCA+PSBjdXIuaW5kZW50KSA6OlxuICAgICAgYnJlYWtcblxuICAgIGxpbmUrKzsgbGFzdCA9IGN1clxuICAgIGlmIChpbm5lckluZGVudCA+IGN1ci5pbmRlbnQpIDo6XG4gICAgICBpbm5lckluZGVudCA9IGN1ci5pbmRlbnRcblxuICAvLyBjYXAgdG8gXG4gIGlubmVySW5kZW50ID0gZmlyc3QuaW5kZW50ID4gaW5uZXJJbmRlbnRcbiAgICA/IGZpcnN0LmluZGVudCA6IGlubmVySW5kZW50XG5cbiAgcmV0dXJuIHtvcCwgaW5uZXJJbmRlbnQsIGZpcnN0LCBsYXN0LCBuZXN0SW5uZXJ9XG5cblxucHAuZmluaXNoT2Zmc2lkZU9wID0gZnVuY3Rpb24gKG9wKSA6OlxuICBjb25zdCBzdGFjayA9IHRoaXMuc3RhdGUub2Zmc2lkZVxuICBsZXQgc3RhY2tUb3AgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXVxuICBpZiAoc3RhY2tUb3AgJiYgc3RhY2tUb3AuaW5LZXl3b3JkQXJnICYmIG9wLmNvZGVCbG9jaykgOjpcbiAgICB0aGlzLnBvcE9mZnNpZGUoKVxuICAgIHRoaXMuc3RhdGUub2Zmc2lkZU5leHRPcCA9IG9wXG4gICAgcmV0dXJuXG5cbiAgaWYgKG9wLmV4dHJhQ2hhcnMpIDo6XG4gICAgdGhpcy5zdGF0ZS5wb3MgKz0gb3AuZXh0cmFDaGFyc1xuXG4gIHRoaXMuX2Jhc2VfZmluaXNoVG9rZW4ob3AudG9rZW5QcmUpXG5cbiAgaWYgKHRoaXMuaXNMb29rYWhlYWQpIDo6IHJldHVyblxuXG4gIHN0YWNrVG9wID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1cbiAgbGV0IGJsayA9IHRoaXMub2Zmc2lkZUJsb2NrKG9wLCBzdGFja1RvcClcbiAgYmxrLmluS2V5d29yZEFyZyA9IG9wLmluS2V5d29yZEFyZyB8fCBzdGFja1RvcCAmJiBzdGFja1RvcC5pbktleXdvcmRBcmdcbiAgdGhpcy5zdGF0ZS5vZmZzaWRlLnB1c2goYmxrKVxuXG5cbnBwLl9iYXNlX3NraXBTcGFjZSA9IGJhc2VQcm90by5za2lwU3BhY2VcbnBwLnNraXBTcGFjZSA9IGZ1bmN0aW9uKCkgOjpcbiAgaWYgKG51bGwgIT09IHRoaXMuc3RhdGUub2Zmc2lkZU5leHRPcCkgOjogcmV0dXJuXG5cbiAgY29uc3Qgc3RhY2sgPSB0aGlzLnN0YXRlLm9mZnNpZGVcbiAgbGV0IHN0YWNrVG9wXG4gIGlmIChzdGFjayAmJiBzdGFjay5sZW5ndGgpIDo6XG4gICAgc3RhY2tUb3AgPSBzdGFja1tzdGFjay5sZW5ndGgtMV1cbiAgICB0aGlzLnN0YXRlLm9mZnNpZGVQb3MgPSBzdGFja1RvcC5sYXN0LnBvc0xhc3RDb250ZW50XG4gIGVsc2UgOjogdGhpcy5zdGF0ZS5vZmZzaWRlUG9zID0gLTFcblxuICB0cnkgOjpcbiAgICB0aGlzLl9iYXNlX3NraXBTcGFjZSgpXG4gICAgdGhpcy5zdGF0ZS5vZmZzaWRlUG9zID0gLTFcbiAgY2F0Y2ggKGVycikgOjpcbiAgICBpZiAoZXJyICE9PSBvZmZzaWRlQnJlYWtvdXQpIDo6IHRocm93IGVyclxuXG5cbnBwLl9iYXNlX3JlYWRUb2tlbiA9IGJhc2VQcm90by5yZWFkVG9rZW5cbnBwLnJlYWRUb2tlbiA9IGZ1bmN0aW9uKGNvZGUpIDo6XG4gIGNvbnN0IG9mZnNpZGVOZXh0T3AgPSB0aGlzLnN0YXRlLm9mZnNpZGVOZXh0T3BcbiAgaWYgKG51bGwgIT09IG9mZnNpZGVOZXh0T3ApIDo6XG4gICAgdGhpcy5zdGF0ZS5vZmZzaWRlTmV4dE9wID0gbnVsbFxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9mZnNpZGVPcChvZmZzaWRlTmV4dE9wKVxuXG4gIGVsc2UgaWYgKHRoaXMuc3RhdGUucG9zID09PSB0aGlzLnN0YXRlLm9mZnNpZGVQb3MpIDo6XG4gICAgcmV0dXJuIHRoaXMucG9wT2Zmc2lkZSgpXG5cbiAgZWxzZSA6OlxuICAgIHJldHVybiB0aGlzLl9iYXNlX3JlYWRUb2tlbihjb2RlKVxuXG5wcC5wb3BPZmZzaWRlID0gZnVuY3Rpb24oKSA6OlxuICBjb25zdCBzdGFjayA9IHRoaXMuc3RhdGUub2Zmc2lkZVxuICBsZXQgc3RhY2tUb3AgPSB0aGlzLmlzTG9va2FoZWFkXG4gICAgPyBzdGFja1tzdGFjay5sZW5ndGgtMV1cbiAgICA6IHN0YWNrLnBvcCgpXG4gIHRoaXMuc3RhdGUub2Zmc2lkZVBvcyA9IC0xXG5cbiAgdGhpcy5fYmFzZV9maW5pc2hUb2tlbihzdGFja1RvcC5vcC50b2tlblBvc3QpXG4gIHJldHVybiBzdGFja1RvcFxuXG5cblxuY29uc3Qgcnhfb2Zmc2lkZSA9IC9eKFsgXFx0XSopKC4qKSQvbWdcbmZ1bmN0aW9uIHBhcnNlT2Zmc2lkZUluZGV4TWFwKGlucHV0KSA6OlxuICBsZXQgbGluZXMgPSBbbnVsbF0sIHBvc0xhc3RDb250ZW50PTAsIGxhc3Q9WycnLCAwXVxuXG4gIGxldCBhbnMgPSBpbnB1dC5yZXBsYWNlIEAgcnhfb2Zmc2lkZSwgKG1hdGNoLCBpbmRlbnQsIGNvbnRlbnQsIHBvcykgPT4gOjpcbiAgICBpZiAoIWNvbnRlbnQpIDo6XG4gICAgICBbaW5kZW50LCBwb3NMYXN0Q29udGVudF0gPSBsYXN0IC8vIGJsYW5rIGxpbmU7IHVzZSBsYXN0IHZhbGlkIGNvbnRlbnQgYXMgZW5kXG4gICAgZWxzZSA6OlxuICAgICAgLy8gdmFsaWQgY29udGVudDsgc2V0IGxhc3QgdG8gY3VycmVudCBpbmRlbnRcbiAgICAgIHBvc0xhc3RDb250ZW50ID0gcG9zICsgbWF0Y2gubGVuZ3RoXG4gICAgICBsYXN0ID0gW2luZGVudCwgcG9zTGFzdENvbnRlbnRdXG5cbiAgICBsaW5lcy5wdXNoKHtsaW5lOiBsaW5lcy5sZW5ndGgsIHBvc0xhc3RDb250ZW50LCBpbmRlbnQsIGNvbnRlbnR9KVxuICAgIHJldHVybiAnJ1xuXG4gIHJldHVybiBsaW5lc1xuXG5cbmNvbnN0IGtleXdvcmRfYmxvY2tfcGFyZW50cyA9XG4gQHt9IElmU3RhdGVtZW50OiAnaWYnXG4gICAsIEZvclN0YXRlbWVudDogJ2ZvcidcbiAgICwgRm9yT2ZTdGF0ZW1lbnQ6ICdmb3InXG4gICAsIFdoaWxlU3RhdGVtZW50OiAnd2hpbGUnXG4gICAsIERvV2hpbGVTdGF0ZW1lbnQ6ICdkby13aGlsZSdcbmNvbnN0IGxpbnRfa2V5d29yZF9ibG9ja19wYXJlbnRzID0gbmV3IFNldCBAIE9iamVjdC5rZXlzIEAga2V5d29yZF9ibG9ja19wYXJlbnRzXG5cbmNvbnN0IGJhYmVsX3BsdWdpbl9pZCA9IGBiYWJlbC1wbHVnaW4tb2Zmc2lkZS0tJHtEYXRlLm5vdygpfWBcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IChiYWJlbCkgPT4gOjpcbiAgcmV0dXJuIDo6XG4gICAgbmFtZTogYmFiZWxfcGx1Z2luX2lkXG4gICAgLCBwcmUoc3RhdGUpIDo6XG4gICAgICB0aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduIEAge30sIGRlZmF1bHRfb2Zmc2lkZVBsdWdpbk9wdHMsIHRoaXMub3B0c1xuXG4gICAgLCBtYW5pcHVsYXRlT3B0aW9ucyhvcHRzLCBwYXJzZXJPcHRzKSA6OlxuICAgICAgICBwYXJzZXJPcHRzLnBsdWdpbnMucHVzaCgnZGVjb3JhdG9ycycsICdmdW5jdGlvbkJpbmQnKVxuICAgICAgICBjb25zdCBvZmZzaWRlUGx1Z2luT3B0cyA9IG9wdHMucGx1Z2luc1xuICAgICAgICAgIC5maWx0ZXIgQCBwbHVnaW4gPT4gcGx1Z2luWzBdICYmIGJhYmVsX3BsdWdpbl9pZCA9PT0gcGx1Z2luWzBdLmtleSAmJiBwbHVnaW5bMV1cbiAgICAgICAgICAubWFwIEAgcGx1Z2luID0+IHBsdWdpblsxXVxuICAgICAgICAgIC5wb3AoKVxuICAgICAgICBwYXJzZXJPcHRzLm9mZnNpZGVQbHVnaW5PcHRzID0gb2Zmc2lkZVBsdWdpbk9wdHMgfHwgZGVmYXVsdF9vZmZzaWRlUGx1Z2luT3B0c1xuXG4gICAgLCB2aXNpdG9yOiA6OlxuICAgICAgICBFeHByZXNzaW9uU3RhdGVtZW50KHBhdGgpIDo6XG4gICAgICAgICAgaWYgKCF0aGlzLm9wdHMua2V5d29yZF9ibG9ja3MpIDo6IHJldHVyblxuICAgICAgICAgIGlmICghbGludF9rZXl3b3JkX2Jsb2NrX3BhcmVudHMuaGFzKHBhdGgucGFyZW50LnR5cGUpKSA6OiByZXR1cm5cblxuICAgICAgICAgIGxldCBrZXl3b3JkID0ga2V5d29yZF9ibG9ja19wYXJlbnRzW3BhdGgucGFyZW50LnR5cGVdXG4gICAgICAgICAgaWYgKCdpZicgPT09IGtleXdvcmQgJiYgcGF0aC5ub2RlID09PSBwYXRoLnBhcmVudC5hbHRlcm5hdGUpIDo6XG4gICAgICAgICAgICBrZXl3b3JkID0gJ2Vsc2UnIC8vIGZpeHVwIGlmL2Vsc2UgY29tYmluZWQgcGFyZW50IGNvbmRpdGlvblxuXG4gICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yIEBcbiAgICAgICAgICAgIGBLZXl3b3JkICcke2tleXdvcmR9JyBzaG91bGQgYmUgZm9sbG93ZWQgYnkgYSBibG9jayBzdGF0ZW1lbnQgdXNpbmcgJzo6JyBvciBtYXRjaGluZyAneycgLyAnfScuIFxcbmAgK1xuICAgICAgICAgICAgYCAgICAoRnJvbSAna2V5d29yZF9ibG9ja3MnIGVuZm9yY2VtZW50IG9wdGlvbiBvZiBiYWJlbC1wbHVnaW4tb2Zmc2lkZSlgXG5cblxuT2JqZWN0LmFzc2lnbiBAIGV4cG9ydHMsXG4gIEB7fVxuICAgIGhvb2tCYWJ5bG9uLFxuICAgIHBhcnNlT2Zmc2lkZUluZGV4TWFwLFxuXG4iXX0=