const babylon = require('babylon');
const tt = babylon.tokTypes;

var _g_offsidePluginOpts;
const default_offsidePluginOpts = { keyword_blocks: true };

const _base_module_parse = babylon.parse;
babylon.parse = (input, options) => {
  _g_offsidePluginOpts = options ? options.offsidePluginOpts : undefined;
  return _base_module_parse(input, options);
};

const Parser = hookBabylon();
const baseProto = Parser.prototype;
const pp = Parser.prototype = Object.create(baseProto);

function hookBabylon() {
  // abuse Babylon token updateContext callback extract
  // the reference to Parser

  let Parser;
  let tgt_patch = babylon.tokTypes.braceL;
  let fn_updateContext = tgt_patch.updateContext;
  tgt_patch.updateContext = function (prevType) {
    tgt_patch.updateContext = fn_updateContext;
    Parser = this.constructor;
  };

  babylon.parse('{}');
  if (!Parser) {
    throw new Error("Failed to hook Babylon Parser");
  }
  return Parser;
}

pp._base_parse = baseProto.parse;
pp.parse = function () {
  this.initOffside();
  return this._base_parse();
};

class OffsideBreakout extends Error {}
const offsideBreakout = new OffsideBreakout();

pp.initOffside = function () {
  this.state.offside = [];
  this.state.offsideNextOp = null;
  this.offside_lines = parseOffsideIndexMap(this.input);
  this.offsidePluginOpts = _g_offsidePluginOpts || {};
  _g_offsidePluginOpts = null;

  this.state._pos = this.state.pos;
  Object.defineProperty(this.state, 'pos', { enumerable: true,
    get() {
      return this._pos;
    }, set(pos) {
      // interrupt skipSpace algorithm when we hit our position 'breakpoint'
      let offPos = this.offsidePos;
      if (offPos >= 0 && pos > offPos) {
        throw offsideBreakout;
      }

      this._pos = pos;
    } });
};

let tt_offside_keyword_with_args = new Set([tt._if, tt._while, tt._for, tt._catch, tt._switch]);

let tt_offside_keyword_lookahead_skip = new Set([tt.parenL, tt.colon, tt.comma, tt.dot]);

let at_offside = { '::': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: false, codeBlock: true },
  '::@': { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: false, extraChars: 1 },
  '::()': { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: false, extraChars: 2 },
  '::{}': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: false, extraChars: 2 },
  '::[]': { tokenPre: tt.bracketL, tokenPost: tt.bracketR, nestInner: false, extraChars: 2 },
  '@': { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: true },
  '@()': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: true, extraChars: 2 },
  '@{}': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: true, extraChars: 2 },
  '@[]': { tokenPre: tt.bracketL, tokenPost: tt.bracketR, nestInner: true, extraChars: 2 }
  // note:  no '@()' -- standardize to use single-char '@ ' instead
  , keyword_args: { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: false, inKeywordArg: true } };

pp._base_finishToken = baseProto.finishToken;
pp.finishToken = function (type, val) {
  const state = this.state;
  state.offsideRecentOp = null;

  if (tt_offside_keyword_with_args.has(type)) {
    let isKeywordAllowed = !this.isLookahead && tt.dot !== state.type;

    if (!isKeywordAllowed) {
      return this._base_finishToken(type, val);
    }

    const lookahead = this.lookahead();

    if (!tt_offside_keyword_lookahead_skip.has(lookahead.type)) {
      state.offsideNextOp = at_offside.keyword_args;
    } else if (lookahead.offsideRecentOp === at_offside['@']) {
      state.offsideNextOp = at_offside.keyword_args;
    }

    return this._base_finishToken(type, val);
  }

  if (type === tt.at || type === tt.doubleColon) {
    const pos0 = state.start,
          pos1 = state.pos + 2;
    const str_op = this.input.slice(pos0, pos1).split(/\s/, 1)[0];

    const op = at_offside[str_op];
    if (op) {
      return this.finishOffsideOp(op);
    }
  }

  if (tt.eof === type) {
    if (state.offside.length) {
      return this.popOffside();
    }
  }

  return this._base_finishToken(type, val);
};

pp.offsideBlock = function (op, stackTop) {
  let offside_lines = this.offside_lines;

  const line0 = this.state.curLine;
  const first = offside_lines[line0];
  const nestInner = op.nestInner && stackTop && line0 === stackTop.first.line;
  const indent = nestInner ? stackTop.innerIndent : first.indent;
  let line = 1 + line0,
      last = first;
  const innerLine = offside_lines[line];
  let innerIndent = innerLine ? innerLine.indent : '';

  while (line < offside_lines.length) {
    let cur = offside_lines[line];
    if (cur.content && indent >= cur.indent) {
      break;
    }

    line++;last = cur;
    if (innerIndent > cur.indent) {
      innerIndent = cur.indent;
    }
  }

  // cap to 
  innerIndent = first.indent > innerIndent ? first.indent : innerIndent;

  return { op, innerIndent, first, last, nestInner };
};

pp.finishOffsideOp = function (op) {
  this.state.offsideRecentOp = op;
  const stack = this.state.offside;
  let stackTop = stack[stack.length - 1];
  if (stackTop && stackTop.inKeywordArg && op.codeBlock) {
    this.popOffside();
    this.state.offsideNextOp = op;
    return;
  }

  if (op.extraChars) {
    this.state.pos += op.extraChars;
  }

  this._base_finishToken(op.tokenPre);

  if (this.isLookahead) {
    return;
  }

  stackTop = stack[stack.length - 1];
  let blk = this.offsideBlock(op, stackTop);
  blk.inKeywordArg = op.inKeywordArg || stackTop && stackTop.inKeywordArg;
  this.state.offside.push(blk);
};

pp._base_skipSpace = baseProto.skipSpace;
pp.skipSpace = function () {
  if (null !== this.state.offsideNextOp) {
    return;
  }

  const stack = this.state.offside;
  let stackTop;
  if (stack && stack.length) {
    stackTop = stack[stack.length - 1];
    this.state.offsidePos = stackTop.last.posLastContent;
  } else {
    this.state.offsidePos = -1;
  }

  try {
    this._base_skipSpace();
    this.state.offsidePos = -1;
  } catch (err) {
    if (err !== offsideBreakout) {
      throw err;
    }
  }
};

pp._base_readToken = baseProto.readToken;
pp.readToken = function (code) {
  const offsideNextOp = this.state.offsideNextOp;
  if (null !== offsideNextOp) {
    this.state.offsideNextOp = null;
    return this.finishOffsideOp(offsideNextOp);
  } else if (this.state.pos === this.state.offsidePos) {
    return this.popOffside();
  } else {
    return this._base_readToken(code);
  }
};

pp.popOffside = function () {
  const stack = this.state.offside;
  let stackTop = this.isLookahead ? stack[stack.length - 1] : stack.pop();
  this.state.offsidePos = -1;

  this._base_finishToken(stackTop.op.tokenPost);
  return stackTop;
};

const rx_offside = /^([ \t]*)(.*)$/mg;
function parseOffsideIndexMap(input) {
  let lines = [null],
      posLastContent = 0,
      last = ['', 0];

  let ans = input.replace(rx_offside, (match, indent, content, pos) => {
    if (!content) {
      [indent, posLastContent] = last; // blank line; use last valid content as end
    } else {
        // valid content; set last to current indent
        posLastContent = pos + match.length;
        last = [indent, posLastContent];
      }

    lines.push({ line: lines.length, posLastContent, indent, content });
    return '';
  });

  return lines;
}

const keyword_block_parents = { IfStatement: 'if',
  ForStatement: 'for',
  WhileStatement: 'while',
  DoWhileStatement: 'do-while' };
const lint_keyword_block_parents = new Set(Object.keys(keyword_block_parents));

const babel_plugin_id = `babel-plugin-offside--${Date.now()}`;
module.exports = exports = babel => {
  return {
    name: babel_plugin_id,
    post(state) {
      //console.dir @ state, @{} colors: true
    }, manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push('decorators', 'functionBind');
      const offsidePluginOpts = opts.plugins.filter(plugin => plugin[0] && babel_plugin_id === plugin[0].key).map(plugin => plugin[1]).pop();
      parserOpts.offsidePluginOpts = offsidePluginOpts || default_offsidePluginOpts;
    }, visitor: {
      ExpressionStatement(path) {
        if (!this.opts.keyword_blocks) {
          return;
        }
        if (!lint_keyword_block_parents.has(path.parent.type)) {
          return;
        }

        let keyword = keyword_block_parents[path.parent.type];
        if ('if' === keyword && path.node === path.parent.alternate) {
          keyword = 'else'; // fixup if/else combined parent condition
        }throw path.buildCodeFrameError(`Keyword '${keyword}' should be followed by a block statement using '::' or matching '{' / '}'. \n` + `    (From 'keyword_blocks' enforcement option of babel-plugin-offside)`);
      } } };
};

Object.assign(exports, {
  hookBabylon,
  parseOffsideIndexMap });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2NvZGUvaW5kZXguanMiXSwibmFtZXMiOlsiYmFieWxvbiIsInJlcXVpcmUiLCJ0dCIsInRva1R5cGVzIiwiX2dfb2Zmc2lkZVBsdWdpbk9wdHMiLCJkZWZhdWx0X29mZnNpZGVQbHVnaW5PcHRzIiwia2V5d29yZF9ibG9ja3MiLCJfYmFzZV9tb2R1bGVfcGFyc2UiLCJwYXJzZSIsImlucHV0Iiwib3B0aW9ucyIsIm9mZnNpZGVQbHVnaW5PcHRzIiwidW5kZWZpbmVkIiwiUGFyc2VyIiwiaG9va0JhYnlsb24iLCJiYXNlUHJvdG8iLCJwcm90b3R5cGUiLCJwcCIsIk9iamVjdCIsImNyZWF0ZSIsInRndF9wYXRjaCIsImJyYWNlTCIsImZuX3VwZGF0ZUNvbnRleHQiLCJ1cGRhdGVDb250ZXh0IiwicHJldlR5cGUiLCJjb25zdHJ1Y3RvciIsIkVycm9yIiwiX2Jhc2VfcGFyc2UiLCJpbml0T2Zmc2lkZSIsIk9mZnNpZGVCcmVha291dCIsIm9mZnNpZGVCcmVha291dCIsInN0YXRlIiwib2Zmc2lkZSIsIm9mZnNpZGVOZXh0T3AiLCJvZmZzaWRlX2xpbmVzIiwicGFyc2VPZmZzaWRlSW5kZXhNYXAiLCJfcG9zIiwicG9zIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2V0Iiwib2ZmUG9zIiwib2Zmc2lkZVBvcyIsInR0X29mZnNpZGVfa2V5d29yZF93aXRoX2FyZ3MiLCJTZXQiLCJfaWYiLCJfd2hpbGUiLCJfZm9yIiwiX2NhdGNoIiwiX3N3aXRjaCIsInR0X29mZnNpZGVfa2V5d29yZF9sb29rYWhlYWRfc2tpcCIsInBhcmVuTCIsImNvbG9uIiwiY29tbWEiLCJkb3QiLCJhdF9vZmZzaWRlIiwidG9rZW5QcmUiLCJ0b2tlblBvc3QiLCJicmFjZVIiLCJuZXN0SW5uZXIiLCJjb2RlQmxvY2siLCJwYXJlblIiLCJleHRyYUNoYXJzIiwiYnJhY2tldEwiLCJicmFja2V0UiIsImtleXdvcmRfYXJncyIsImluS2V5d29yZEFyZyIsIl9iYXNlX2ZpbmlzaFRva2VuIiwiZmluaXNoVG9rZW4iLCJ0eXBlIiwidmFsIiwib2Zmc2lkZVJlY2VudE9wIiwiaGFzIiwiaXNLZXl3b3JkQWxsb3dlZCIsImlzTG9va2FoZWFkIiwibG9va2FoZWFkIiwiYXQiLCJkb3VibGVDb2xvbiIsInBvczAiLCJzdGFydCIsInBvczEiLCJzdHJfb3AiLCJzbGljZSIsInNwbGl0Iiwib3AiLCJmaW5pc2hPZmZzaWRlT3AiLCJlb2YiLCJsZW5ndGgiLCJwb3BPZmZzaWRlIiwib2Zmc2lkZUJsb2NrIiwic3RhY2tUb3AiLCJsaW5lMCIsImN1ckxpbmUiLCJmaXJzdCIsImxpbmUiLCJpbmRlbnQiLCJpbm5lckluZGVudCIsImxhc3QiLCJpbm5lckxpbmUiLCJjdXIiLCJjb250ZW50Iiwic3RhY2siLCJibGsiLCJwdXNoIiwiX2Jhc2Vfc2tpcFNwYWNlIiwic2tpcFNwYWNlIiwicG9zTGFzdENvbnRlbnQiLCJlcnIiLCJfYmFzZV9yZWFkVG9rZW4iLCJyZWFkVG9rZW4iLCJjb2RlIiwicG9wIiwicnhfb2Zmc2lkZSIsImxpbmVzIiwiYW5zIiwicmVwbGFjZSIsIm1hdGNoIiwia2V5d29yZF9ibG9ja19wYXJlbnRzIiwiSWZTdGF0ZW1lbnQiLCJGb3JTdGF0ZW1lbnQiLCJXaGlsZVN0YXRlbWVudCIsIkRvV2hpbGVTdGF0ZW1lbnQiLCJsaW50X2tleXdvcmRfYmxvY2tfcGFyZW50cyIsImtleXMiLCJiYWJlbF9wbHVnaW5faWQiLCJEYXRlIiwibm93IiwibW9kdWxlIiwiZXhwb3J0cyIsImJhYmVsIiwibmFtZSIsInBvc3QiLCJtYW5pcHVsYXRlT3B0aW9ucyIsIm9wdHMiLCJwYXJzZXJPcHRzIiwicGx1Z2lucyIsImZpbHRlciIsInBsdWdpbiIsImtleSIsIm1hcCIsInZpc2l0b3IiLCJFeHByZXNzaW9uU3RhdGVtZW50IiwicGF0aCIsInBhcmVudCIsImtleXdvcmQiLCJub2RlIiwiYWx0ZXJuYXRlIiwiYnVpbGRDb2RlRnJhbWVFcnJvciIsImFzc2lnbiJdLCJt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aUJBQVc1SCxpQkFBWCxHQUErQkEscUJBQXFCTix5QkFBcEQ7QUFBNkUsS0FYNUUsRUFhSHdJLFNBQVM7QUFDUEMsMEJBQW9CQyxJQUFwQixFQUEwQjtBQUN4QixZQUFJLENBQUMsS0FBS1QsSUFBTCxDQUFVaEksY0FBZixFQUErQjtBQUFHO0FBQU07QUFDeEMsWUFBSSxDQUFDcUgsMkJBQTJCbEQsR0FBM0IsQ0FBK0JzRSxLQUFLQyxNQUFMLENBQVkxRSxJQUEzQyxDQUFMLEVBQXVEO0FBQUc7QUFBTTs7QUFFaEUsWUFBSTJFLFVBQVUzQixzQkFBc0J5QixLQUFLQyxNQUFMLENBQVkxRSxJQUFsQyxDQUFkO0FBQ0EsWUFBSSxTQUFTMkUsT0FBVCxJQUFvQkYsS0FBS0csSUFBTCxLQUFjSCxLQUFLQyxNQUFMLENBQVlHLFNBQWxELEVBQTZEO0FBQzNERixvQkFBVSxNQUFWLENBRDJELENBQzFDO0FBQTBDLFNBRTdELE1BQU1GLEtBQUtLLG1CQUFMLENBQ0gsWUFBV0gsT0FBUSxnRkFBcEIsR0FDQyx3RUFGRyxDQUFOO0FBRTBFLE9BWHJFLEVBYk4sRUFBUDtBQXdCa0YsQ0F6QnBGOztBQTRCQS9ILE9BQU9tSSxNQUFQLENBQWdCcEIsT0FBaEIsRUFDRTtBQUNFbkgsYUFERjtBQUVFcUIsc0JBRkYsRUFERiIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGJhYnlsb24gPSByZXF1aXJlKCdiYWJ5bG9uJylcbmNvbnN0IHR0ID0gYmFieWxvbi50b2tUeXBlc1xuXG52YXIgX2dfb2Zmc2lkZVBsdWdpbk9wdHNcbmNvbnN0IGRlZmF1bHRfb2Zmc2lkZVBsdWdpbk9wdHMgPVxuICBAe30ga2V5d29yZF9ibG9ja3M6IHRydWVcblxuY29uc3QgX2Jhc2VfbW9kdWxlX3BhcnNlID0gYmFieWxvbi5wYXJzZVxuYmFieWxvbi5wYXJzZSA9IChpbnB1dCwgb3B0aW9ucykgPT4gOjpcbiAgX2dfb2Zmc2lkZVBsdWdpbk9wdHMgPSBvcHRpb25zID8gb3B0aW9ucy5vZmZzaWRlUGx1Z2luT3B0cyA6IHVuZGVmaW5lZFxuICByZXR1cm4gX2Jhc2VfbW9kdWxlX3BhcnNlKGlucHV0LCBvcHRpb25zKVxuXG5jb25zdCBQYXJzZXIgPSBob29rQmFieWxvbigpXG5jb25zdCBiYXNlUHJvdG8gPSBQYXJzZXIucHJvdG90eXBlXG5jb25zdCBwcCA9IFBhcnNlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm90bylcblxuZnVuY3Rpb24gaG9va0JhYnlsb24oKSA6OlxuICAvLyBhYnVzZSBCYWJ5bG9uIHRva2VuIHVwZGF0ZUNvbnRleHQgY2FsbGJhY2sgZXh0cmFjdFxuICAvLyB0aGUgcmVmZXJlbmNlIHRvIFBhcnNlclxuXG4gIGxldCBQYXJzZXJcbiAgbGV0IHRndF9wYXRjaCA9IGJhYnlsb24udG9rVHlwZXMuYnJhY2VMXG4gIGxldCBmbl91cGRhdGVDb250ZXh0ID0gdGd0X3BhdGNoLnVwZGF0ZUNvbnRleHRcbiAgdGd0X3BhdGNoLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAocHJldlR5cGUpIDo6XG4gICAgdGd0X3BhdGNoLnVwZGF0ZUNvbnRleHQgPSBmbl91cGRhdGVDb250ZXh0XG4gICAgUGFyc2VyID0gdGhpcy5jb25zdHJ1Y3RvclxuXG4gIGJhYnlsb24ucGFyc2UoJ3t9JylcbiAgaWYgKCFQYXJzZXIpIDo6XG4gICAgdGhyb3cgbmV3IEVycm9yIEAgXCJGYWlsZWQgdG8gaG9vayBCYWJ5bG9uIFBhcnNlclwiXG4gIHJldHVybiBQYXJzZXJcblxuXG5cbnBwLl9iYXNlX3BhcnNlID0gYmFzZVByb3RvLnBhcnNlXG5wcC5wYXJzZSA9IGZ1bmN0aW9uKCkgOjpcbiAgdGhpcy5pbml0T2Zmc2lkZSgpXG4gIHJldHVybiB0aGlzLl9iYXNlX3BhcnNlKClcblxuXG5jbGFzcyBPZmZzaWRlQnJlYWtvdXQgZXh0ZW5kcyBFcnJvciB7fVxuY29uc3Qgb2Zmc2lkZUJyZWFrb3V0ID0gbmV3IE9mZnNpZGVCcmVha291dCgpXG5cbnBwLmluaXRPZmZzaWRlID0gZnVuY3Rpb24oKSA6OlxuICB0aGlzLnN0YXRlLm9mZnNpZGUgPSBbXVxuICB0aGlzLnN0YXRlLm9mZnNpZGVOZXh0T3AgPSBudWxsXG4gIHRoaXMub2Zmc2lkZV9saW5lcyA9IHBhcnNlT2Zmc2lkZUluZGV4TWFwKHRoaXMuaW5wdXQpXG4gIHRoaXMub2Zmc2lkZVBsdWdpbk9wdHMgPSBfZ19vZmZzaWRlUGx1Z2luT3B0cyB8fCB7fVxuICBfZ19vZmZzaWRlUGx1Z2luT3B0cyA9IG51bGxcblxuICB0aGlzLnN0YXRlLl9wb3MgPSB0aGlzLnN0YXRlLnBvc1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkgQCB0aGlzLnN0YXRlLCAncG9zJyxcbiAgICBAe30gZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgLCBnZXQoKSA6OiByZXR1cm4gdGhpcy5fcG9zXG4gICAgICAsIHNldChwb3MpIDo6XG4gICAgICAgICAgLy8gaW50ZXJydXB0IHNraXBTcGFjZSBhbGdvcml0aG0gd2hlbiB3ZSBoaXQgb3VyIHBvc2l0aW9uICdicmVha3BvaW50J1xuICAgICAgICAgIGxldCBvZmZQb3MgPSB0aGlzLm9mZnNpZGVQb3NcbiAgICAgICAgICBpZiAob2ZmUG9zPj0wICYmIChwb3MgPiBvZmZQb3MpKSA6OlxuICAgICAgICAgICAgdGhyb3cgb2Zmc2lkZUJyZWFrb3V0XG5cbiAgICAgICAgICB0aGlzLl9wb3MgPSBwb3NcblxuXG5sZXQgdHRfb2Zmc2lkZV9rZXl3b3JkX3dpdGhfYXJncyA9IG5ldyBTZXQgQFxuICBAW10gdHQuX2lmLCB0dC5fd2hpbGUsIHR0Ll9mb3JcbiAgICAsIHR0Ll9jYXRjaCwgdHQuX3N3aXRjaFxuXG5sZXQgdHRfb2Zmc2lkZV9rZXl3b3JkX2xvb2thaGVhZF9za2lwID0gbmV3IFNldCBAXG4gIEBbXSB0dC5wYXJlbkwsIHR0LmNvbG9uLCB0dC5jb21tYSwgdHQuZG90XG5cbmxldCBhdF9vZmZzaWRlID1cbiAgQHt9ICc6Oic6ICAge3Rva2VuUHJlOiB0dC5icmFjZUwsIHRva2VuUG9zdDogdHQuYnJhY2VSLCBuZXN0SW5uZXI6IGZhbHNlLCBjb2RlQmxvY2s6IHRydWV9XG4gICAgLCAnOjpAJzogIHt0b2tlblByZTogdHQucGFyZW5MLCB0b2tlblBvc3Q6IHR0LnBhcmVuUiwgbmVzdElubmVyOiBmYWxzZSwgZXh0cmFDaGFyczogMX1cbiAgICAsICc6OigpJzoge3Rva2VuUHJlOiB0dC5wYXJlbkwsIHRva2VuUG9zdDogdHQucGFyZW5SLCBuZXN0SW5uZXI6IGZhbHNlLCBleHRyYUNoYXJzOiAyfVxuICAgICwgJzo6e30nOiB7dG9rZW5QcmU6IHR0LmJyYWNlTCwgdG9rZW5Qb3N0OiB0dC5icmFjZVIsIG5lc3RJbm5lcjogZmFsc2UsIGV4dHJhQ2hhcnM6IDJ9XG4gICAgLCAnOjpbXSc6IHt0b2tlblByZTogdHQuYnJhY2tldEwsIHRva2VuUG9zdDogdHQuYnJhY2tldFIsIG5lc3RJbm5lcjogZmFsc2UsIGV4dHJhQ2hhcnM6IDJ9XG4gICAgLCAnQCc6ICAgIHt0b2tlblByZTogdHQucGFyZW5MLCB0b2tlblBvc3Q6IHR0LnBhcmVuUiwgbmVzdElubmVyOiB0cnVlfVxuICAgICwgJ0AoKSc6ICB7dG9rZW5QcmU6IHR0LmJyYWNlTCwgdG9rZW5Qb3N0OiB0dC5icmFjZVIsIG5lc3RJbm5lcjogdHJ1ZSwgZXh0cmFDaGFyczogMn1cbiAgICAsICdAe30nOiAge3Rva2VuUHJlOiB0dC5icmFjZUwsIHRva2VuUG9zdDogdHQuYnJhY2VSLCBuZXN0SW5uZXI6IHRydWUsIGV4dHJhQ2hhcnM6IDJ9XG4gICAgLCAnQFtdJzogIHt0b2tlblByZTogdHQuYnJhY2tldEwsIHRva2VuUG9zdDogdHQuYnJhY2tldFIsIG5lc3RJbm5lcjogdHJ1ZSwgZXh0cmFDaGFyczogMn1cbiAgICAvLyBub3RlOiAgbm8gJ0AoKScgLS0gc3RhbmRhcmRpemUgdG8gdXNlIHNpbmdsZS1jaGFyICdAICcgaW5zdGVhZFxuICAgICwga2V5d29yZF9hcmdzOiB7dG9rZW5QcmU6IHR0LnBhcmVuTCwgdG9rZW5Qb3N0OiB0dC5wYXJlblIsIG5lc3RJbm5lcjogZmFsc2UsIGluS2V5d29yZEFyZzogdHJ1ZX1cblxucHAuX2Jhc2VfZmluaXNoVG9rZW4gPSBiYXNlUHJvdG8uZmluaXNoVG9rZW5cbnBwLmZpbmlzaFRva2VuID0gZnVuY3Rpb24odHlwZSwgdmFsKSA6OlxuICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGVcbiAgc3RhdGUub2Zmc2lkZVJlY2VudE9wID0gbnVsbFxuXG4gIGlmICh0dF9vZmZzaWRlX2tleXdvcmRfd2l0aF9hcmdzLmhhcyh0eXBlKSkgOjpcbiAgICBsZXQgaXNLZXl3b3JkQWxsb3dlZCA9ICF0aGlzLmlzTG9va2FoZWFkXG4gICAgICAmJiB0dC5kb3QgIT09IHN0YXRlLnR5cGVcblxuICAgIGlmICghaXNLZXl3b3JkQWxsb3dlZCkgOjpcbiAgICAgIHJldHVybiB0aGlzLl9iYXNlX2ZpbmlzaFRva2VuKHR5cGUsIHZhbClcblxuICAgIGNvbnN0IGxvb2thaGVhZCA9IHRoaXMubG9va2FoZWFkKClcblxuICAgIGlmICghdHRfb2Zmc2lkZV9rZXl3b3JkX2xvb2thaGVhZF9za2lwLmhhcyhsb29rYWhlYWQudHlwZSkpIDo6XG4gICAgICBzdGF0ZS5vZmZzaWRlTmV4dE9wID0gYXRfb2Zmc2lkZS5rZXl3b3JkX2FyZ3NcbiAgICBlbHNlIGlmIChsb29rYWhlYWQub2Zmc2lkZVJlY2VudE9wID09PSBhdF9vZmZzaWRlWydAJ10pIDo6XG4gICAgICBzdGF0ZS5vZmZzaWRlTmV4dE9wID0gYXRfb2Zmc2lkZS5rZXl3b3JkX2FyZ3NcblxuICAgIHJldHVybiB0aGlzLl9iYXNlX2ZpbmlzaFRva2VuKHR5cGUsIHZhbClcblxuICBpZiAodHlwZSA9PT0gdHQuYXQgfHwgdHlwZSA9PT0gdHQuZG91YmxlQ29sb24pIDo6XG4gICAgY29uc3QgcG9zMCA9IHN0YXRlLnN0YXJ0LCBwb3MxID0gc3RhdGUucG9zICsgMlxuICAgIGNvbnN0IHN0cl9vcCA9IHRoaXMuaW5wdXQuc2xpY2UocG9zMCwgcG9zMSkuc3BsaXQoL1xccy8sIDEpWzBdXG5cbiAgICBjb25zdCBvcCA9IGF0X29mZnNpZGVbc3RyX29wXVxuICAgIGlmIChvcCkgOjogcmV0dXJuIHRoaXMuZmluaXNoT2Zmc2lkZU9wKG9wKVxuXG4gIGlmICh0dC5lb2YgPT09IHR5cGUpIDo6XG4gICAgaWYgKHN0YXRlLm9mZnNpZGUubGVuZ3RoKSA6OlxuICAgICAgcmV0dXJuIHRoaXMucG9wT2Zmc2lkZSgpXG5cbiAgcmV0dXJuIHRoaXMuX2Jhc2VfZmluaXNoVG9rZW4odHlwZSwgdmFsKVxuXG5cblxucHAub2Zmc2lkZUJsb2NrID0gZnVuY3Rpb24gKG9wLCBzdGFja1RvcCkgOjpcbiAgbGV0IG9mZnNpZGVfbGluZXMgPSB0aGlzLm9mZnNpZGVfbGluZXNcblxuICBjb25zdCBsaW5lMCA9IHRoaXMuc3RhdGUuY3VyTGluZVxuICBjb25zdCBmaXJzdCA9IG9mZnNpZGVfbGluZXNbbGluZTBdXG4gIGNvbnN0IG5lc3RJbm5lciA9IG9wLm5lc3RJbm5lciAmJiBzdGFja1RvcCAmJiBsaW5lMCA9PT0gc3RhY2tUb3AuZmlyc3QubGluZVxuICBjb25zdCBpbmRlbnQgPSBuZXN0SW5uZXIgPyBzdGFja1RvcC5pbm5lckluZGVudCA6IGZpcnN0LmluZGVudFxuICBsZXQgbGluZSA9IDErbGluZTAsIGxhc3QgPSBmaXJzdFxuICBjb25zdCBpbm5lckxpbmUgPSBvZmZzaWRlX2xpbmVzW2xpbmVdXG4gIGxldCBpbm5lckluZGVudCA9IGlubmVyTGluZSA/IGlubmVyTGluZS5pbmRlbnQgOiAnJ1xuXG4gIHdoaWxlIChsaW5lIDwgb2Zmc2lkZV9saW5lcy5sZW5ndGgpIDo6XG4gICAgbGV0IGN1ciA9IG9mZnNpZGVfbGluZXNbbGluZV1cbiAgICBpZiAoY3VyLmNvbnRlbnQgJiYgaW5kZW50ID49IGN1ci5pbmRlbnQpIDo6XG4gICAgICBicmVha1xuXG4gICAgbGluZSsrOyBsYXN0ID0gY3VyXG4gICAgaWYgKGlubmVySW5kZW50ID4gY3VyLmluZGVudCkgOjpcbiAgICAgIGlubmVySW5kZW50ID0gY3VyLmluZGVudFxuXG4gIC8vIGNhcCB0byBcbiAgaW5uZXJJbmRlbnQgPSBmaXJzdC5pbmRlbnQgPiBpbm5lckluZGVudFxuICAgID8gZmlyc3QuaW5kZW50IDogaW5uZXJJbmRlbnRcblxuICByZXR1cm4ge29wLCBpbm5lckluZGVudCwgZmlyc3QsIGxhc3QsIG5lc3RJbm5lcn1cblxuXG5wcC5maW5pc2hPZmZzaWRlT3AgPSBmdW5jdGlvbiAob3ApIDo6XG4gIHRoaXMuc3RhdGUub2Zmc2lkZVJlY2VudE9wID0gb3BcbiAgY29uc3Qgc3RhY2sgPSB0aGlzLnN0YXRlLm9mZnNpZGVcbiAgbGV0IHN0YWNrVG9wID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1cbiAgaWYgKHN0YWNrVG9wICYmIHN0YWNrVG9wLmluS2V5d29yZEFyZyAmJiBvcC5jb2RlQmxvY2spIDo6XG4gICAgdGhpcy5wb3BPZmZzaWRlKClcbiAgICB0aGlzLnN0YXRlLm9mZnNpZGVOZXh0T3AgPSBvcFxuICAgIHJldHVyblxuXG4gIGlmIChvcC5leHRyYUNoYXJzKSA6OlxuICAgIHRoaXMuc3RhdGUucG9zICs9IG9wLmV4dHJhQ2hhcnNcblxuICB0aGlzLl9iYXNlX2ZpbmlzaFRva2VuKG9wLnRva2VuUHJlKVxuXG4gIGlmICh0aGlzLmlzTG9va2FoZWFkKSA6OiByZXR1cm5cblxuICBzdGFja1RvcCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXG4gIGxldCBibGsgPSB0aGlzLm9mZnNpZGVCbG9jayhvcCwgc3RhY2tUb3ApXG4gIGJsay5pbktleXdvcmRBcmcgPSBvcC5pbktleXdvcmRBcmcgfHwgc3RhY2tUb3AgJiYgc3RhY2tUb3AuaW5LZXl3b3JkQXJnXG4gIHRoaXMuc3RhdGUub2Zmc2lkZS5wdXNoKGJsaylcblxuXG5wcC5fYmFzZV9za2lwU3BhY2UgPSBiYXNlUHJvdG8uc2tpcFNwYWNlXG5wcC5za2lwU3BhY2UgPSBmdW5jdGlvbigpIDo6XG4gIGlmIChudWxsICE9PSB0aGlzLnN0YXRlLm9mZnNpZGVOZXh0T3ApIDo6IHJldHVyblxuXG4gIGNvbnN0IHN0YWNrID0gdGhpcy5zdGF0ZS5vZmZzaWRlXG4gIGxldCBzdGFja1RvcFxuICBpZiAoc3RhY2sgJiYgc3RhY2subGVuZ3RoKSA6OlxuICAgIHN0YWNrVG9wID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdXG4gICAgdGhpcy5zdGF0ZS5vZmZzaWRlUG9zID0gc3RhY2tUb3AubGFzdC5wb3NMYXN0Q29udGVudFxuICBlbHNlIDo6IHRoaXMuc3RhdGUub2Zmc2lkZVBvcyA9IC0xXG5cbiAgdHJ5IDo6XG4gICAgdGhpcy5fYmFzZV9za2lwU3BhY2UoKVxuICAgIHRoaXMuc3RhdGUub2Zmc2lkZVBvcyA9IC0xXG4gIGNhdGNoIChlcnIpIDo6XG4gICAgaWYgKGVyciAhPT0gb2Zmc2lkZUJyZWFrb3V0KSA6OiB0aHJvdyBlcnJcblxuXG5wcC5fYmFzZV9yZWFkVG9rZW4gPSBiYXNlUHJvdG8ucmVhZFRva2VuXG5wcC5yZWFkVG9rZW4gPSBmdW5jdGlvbihjb2RlKSA6OlxuICBjb25zdCBvZmZzaWRlTmV4dE9wID0gdGhpcy5zdGF0ZS5vZmZzaWRlTmV4dE9wXG4gIGlmIChudWxsICE9PSBvZmZzaWRlTmV4dE9wKSA6OlxuICAgIHRoaXMuc3RhdGUub2Zmc2lkZU5leHRPcCA9IG51bGxcbiAgICByZXR1cm4gdGhpcy5maW5pc2hPZmZzaWRlT3Aob2Zmc2lkZU5leHRPcClcblxuICBlbHNlIGlmICh0aGlzLnN0YXRlLnBvcyA9PT0gdGhpcy5zdGF0ZS5vZmZzaWRlUG9zKSA6OlxuICAgIHJldHVybiB0aGlzLnBvcE9mZnNpZGUoKVxuXG4gIGVsc2UgOjpcbiAgICByZXR1cm4gdGhpcy5fYmFzZV9yZWFkVG9rZW4oY29kZSlcblxucHAucG9wT2Zmc2lkZSA9IGZ1bmN0aW9uKCkgOjpcbiAgY29uc3Qgc3RhY2sgPSB0aGlzLnN0YXRlLm9mZnNpZGVcbiAgbGV0IHN0YWNrVG9wID0gdGhpcy5pc0xvb2thaGVhZFxuICAgID8gc3RhY2tbc3RhY2subGVuZ3RoLTFdXG4gICAgOiBzdGFjay5wb3AoKVxuICB0aGlzLnN0YXRlLm9mZnNpZGVQb3MgPSAtMVxuXG4gIHRoaXMuX2Jhc2VfZmluaXNoVG9rZW4oc3RhY2tUb3Aub3AudG9rZW5Qb3N0KVxuICByZXR1cm4gc3RhY2tUb3BcblxuXG5cbmNvbnN0IHJ4X29mZnNpZGUgPSAvXihbIFxcdF0qKSguKikkL21nXG5mdW5jdGlvbiBwYXJzZU9mZnNpZGVJbmRleE1hcChpbnB1dCkgOjpcbiAgbGV0IGxpbmVzID0gW251bGxdLCBwb3NMYXN0Q29udGVudD0wLCBsYXN0PVsnJywgMF1cblxuICBsZXQgYW5zID0gaW5wdXQucmVwbGFjZSBAIHJ4X29mZnNpZGUsIChtYXRjaCwgaW5kZW50LCBjb250ZW50LCBwb3MpID0+IDo6XG4gICAgaWYgKCFjb250ZW50KSA6OlxuICAgICAgW2luZGVudCwgcG9zTGFzdENvbnRlbnRdID0gbGFzdCAvLyBibGFuayBsaW5lOyB1c2UgbGFzdCB2YWxpZCBjb250ZW50IGFzIGVuZFxuICAgIGVsc2UgOjpcbiAgICAgIC8vIHZhbGlkIGNvbnRlbnQ7IHNldCBsYXN0IHRvIGN1cnJlbnQgaW5kZW50XG4gICAgICBwb3NMYXN0Q29udGVudCA9IHBvcyArIG1hdGNoLmxlbmd0aFxuICAgICAgbGFzdCA9IFtpbmRlbnQsIHBvc0xhc3RDb250ZW50XVxuXG4gICAgbGluZXMucHVzaCh7bGluZTogbGluZXMubGVuZ3RoLCBwb3NMYXN0Q29udGVudCwgaW5kZW50LCBjb250ZW50fSlcbiAgICByZXR1cm4gJydcblxuICByZXR1cm4gbGluZXNcblxuXG5jb25zdCBrZXl3b3JkX2Jsb2NrX3BhcmVudHMgPVxuIEB7fSBJZlN0YXRlbWVudDogJ2lmJ1xuICAgLCBGb3JTdGF0ZW1lbnQ6ICdmb3InXG4gICAsIFdoaWxlU3RhdGVtZW50OiAnd2hpbGUnXG4gICAsIERvV2hpbGVTdGF0ZW1lbnQ6ICdkby13aGlsZSdcbmNvbnN0IGxpbnRfa2V5d29yZF9ibG9ja19wYXJlbnRzID0gbmV3IFNldCBAIE9iamVjdC5rZXlzIEAga2V5d29yZF9ibG9ja19wYXJlbnRzXG5cbmNvbnN0IGJhYmVsX3BsdWdpbl9pZCA9IGBiYWJlbC1wbHVnaW4tb2Zmc2lkZS0tJHtEYXRlLm5vdygpfWBcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IChiYWJlbCkgPT4gOjpcbiAgcmV0dXJuIDo6XG4gICAgbmFtZTogYmFiZWxfcGx1Z2luX2lkXG4gICAgLCBwb3N0KHN0YXRlKSA6OlxuICAgICAgLy9jb25zb2xlLmRpciBAIHN0YXRlLCBAe30gY29sb3JzOiB0cnVlXG5cbiAgICAsIG1hbmlwdWxhdGVPcHRpb25zKG9wdHMsIHBhcnNlck9wdHMpIDo6XG4gICAgICAgIHBhcnNlck9wdHMucGx1Z2lucy5wdXNoKCdkZWNvcmF0b3JzJywgJ2Z1bmN0aW9uQmluZCcpXG4gICAgICAgIGNvbnN0IG9mZnNpZGVQbHVnaW5PcHRzID0gb3B0cy5wbHVnaW5zXG4gICAgICAgICAgLmZpbHRlciBAIHBsdWdpbiA9PiBwbHVnaW5bMF0gJiYgYmFiZWxfcGx1Z2luX2lkID09PSBwbHVnaW5bMF0ua2V5XG4gICAgICAgICAgLm1hcCBAIHBsdWdpbiA9PiBwbHVnaW5bMV1cbiAgICAgICAgICAucG9wKClcbiAgICAgICAgcGFyc2VyT3B0cy5vZmZzaWRlUGx1Z2luT3B0cyA9IG9mZnNpZGVQbHVnaW5PcHRzIHx8IGRlZmF1bHRfb2Zmc2lkZVBsdWdpbk9wdHNcblxuICAgICwgdmlzaXRvcjogOjpcbiAgICAgICAgRXhwcmVzc2lvblN0YXRlbWVudChwYXRoKSA6OlxuICAgICAgICAgIGlmICghdGhpcy5vcHRzLmtleXdvcmRfYmxvY2tzKSA6OiByZXR1cm5cbiAgICAgICAgICBpZiAoIWxpbnRfa2V5d29yZF9ibG9ja19wYXJlbnRzLmhhcyhwYXRoLnBhcmVudC50eXBlKSkgOjogcmV0dXJuXG5cbiAgICAgICAgICBsZXQga2V5d29yZCA9IGtleXdvcmRfYmxvY2tfcGFyZW50c1twYXRoLnBhcmVudC50eXBlXVxuICAgICAgICAgIGlmICgnaWYnID09PSBrZXl3b3JkICYmIHBhdGgubm9kZSA9PT0gcGF0aC5wYXJlbnQuYWx0ZXJuYXRlKSA6OlxuICAgICAgICAgICAga2V5d29yZCA9ICdlbHNlJyAvLyBmaXh1cCBpZi9lbHNlIGNvbWJpbmVkIHBhcmVudCBjb25kaXRpb25cblxuICAgICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvciBAXG4gICAgICAgICAgICBgS2V5d29yZCAnJHtrZXl3b3JkfScgc2hvdWxkIGJlIGZvbGxvd2VkIGJ5IGEgYmxvY2sgc3RhdGVtZW50IHVzaW5nICc6Oicgb3IgbWF0Y2hpbmcgJ3snIC8gJ30nLiBcXG5gICtcbiAgICAgICAgICAgIGAgICAgKEZyb20gJ2tleXdvcmRfYmxvY2tzJyBlbmZvcmNlbWVudCBvcHRpb24gb2YgYmFiZWwtcGx1Z2luLW9mZnNpZGUpYFxuXG5cbk9iamVjdC5hc3NpZ24gQCBleHBvcnRzLFxuICBAe31cbiAgICBob29rQmFieWxvbixcbiAgICBwYXJzZU9mZnNpZGVJbmRleE1hcCxcblxuIl19