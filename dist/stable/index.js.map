{"version":3,"sources":["../code/index.js"],"names":["assert","require","babylon","tt","tokTypes","_g_offsidePluginOpts","default_offsidePluginOpts","keyword_blocks","_base_module_parse","parse","input","options","offsidePluginOpts","undefined","Parser","hookBabylon","baseProto","prototype","pp","Object","create","tgt_patch","braceL","fn_updateContext","updateContext","prevType","constructor","Error","_base_parse","initOffside","OffsideBreakout","offsideBreakout","state","offside","offsideNextOp","offside_lines","parseOffsideIndexMap","_pos","pos","defineProperty","enumerable","get","set","offPos","offsidePos","tt_offside","braceR","parenL","parenR","bracketL","bracketR","tt_offside_keyword_with_args","Set","_if","_while","_for","_catch","_switch","tt_offside_keyword_with_block","_try","_finally","_else","_do","at_offside","tokenPre","tokenPost","nestInner","codeBlock","extraChars","keyword_args","inKeywordArg","keyword_lint","_base_parseParenExpression","parseParenExpression","err","stack","stackTop","length","message","startsWith","raise","first","posLastContent","_base_finishToken","finishToken","type","val","offsideRecentOp","isKeywordAllowed","isLookahead","dot","exprAllowed","context","tip_context","isExpr","has","lookahead","label","at","doubleColon","pos0","start","pos1","str_op","slice","split","op","finishOffsideOp","eof","popOffside","offsideBlock","line0","curLine","line","indent","innerIndent","last","cur","content","blk","push","_base_skipSpace","skipSpace","_base_readToken","readToken","code","pop","tt_post","rx_offside","lines","ans","replace","match","babel_plugin_id","Date","now","module","exports","babel","name","manipulateOptions","opts","parserOpts","plugins","filter","plugin","key","assign"],"mappings":"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","file":"index.js","sourcesContent":["'use strict'\nconst assert = require('assert')\nconst babylon = require('babylon')\nconst tt = babylon.tokTypes\n\nvar _g_offsidePluginOpts\nconst default_offsidePluginOpts =\n  @{} keyword_blocks: true\n\nconst _base_module_parse = babylon.parse\nbabylon.parse = (input, options) => ::\n  _g_offsidePluginOpts = options ? options.offsidePluginOpts : undefined\n  return _base_module_parse(input, options)\n\nconst Parser = hookBabylon()\nconst baseProto = Parser.prototype\nconst pp = Parser.prototype = Object.create(baseProto)\n\nfunction hookBabylon() ::\n  // abuse Babylon token updateContext callback extract\n  // the reference to Parser\n\n  let Parser\n  let tgt_patch = babylon.tokTypes.braceL\n  let fn_updateContext = tgt_patch.updateContext\n  tgt_patch.updateContext = function (prevType) ::\n    tgt_patch.updateContext = fn_updateContext\n    Parser = this.constructor\n\n  babylon.parse('{}')\n  if (!Parser) ::\n    throw new Error @ \"Failed to hook Babylon Parser\"\n  return Parser\n\n\n\npp._base_parse = baseProto.parse\npp.parse = function() ::\n  this.initOffside()\n  return this._base_parse()\n\n\nclass OffsideBreakout extends Error {}\nconst offsideBreakout = new OffsideBreakout()\n\npp.initOffside = function() ::\n  this.state.offside = []\n  this.state.offsideNextOp = null\n  this.offside_lines = parseOffsideIndexMap(this.input)\n  this.offsidePluginOpts = _g_offsidePluginOpts || default_offsidePluginOpts\n  _g_offsidePluginOpts = null\n\n  this.state._pos = this.state.pos\n  Object.defineProperty @ this.state, 'pos',\n    @{} enumerable: true\n      , get() :: return this._pos\n      , set(pos) ::\n          // interrupt skipSpace algorithm when we hit our position 'breakpoint'\n          let offPos = this.offsidePos\n          if (offPos>=0 && (pos > offPos)) ::\n            throw offsideBreakout\n\n          this._pos = pos\n\n\nlet tt_offside =\n  @{} '{': tt.braceL,   '}': tt.braceR\n    , '(': tt.parenL,   ')': tt.parenR\n    , '[': tt.bracketL, ']': tt.bracketR\n\nlet tt_offside_keyword_with_args = new Set @\n  @[] tt._if, tt._while, tt._for\n    , tt._catch, tt._switch\n\nlet tt_offside_keyword_with_block = new Set @\n  @[] tt._try, tt._finally, tt._else, tt._do\n\nlet at_offside =\n  @{} '::':   {tokenPre: '{', tokenPost: '}', nestInner: false, codeBlock: true}\n    , '::@':  {tokenPre: '(', tokenPost: ')', nestInner: false, extraChars: 1}\n    , '::()': {tokenPre: '(', tokenPost: ')', nestInner: false, extraChars: 2}\n    , '::{}': {tokenPre: '{', tokenPost: '}', nestInner: false, extraChars: 2}\n    , '::[]': {tokenPre: '[', tokenPost: ']', nestInner: false, extraChars: 2}\n    , '@':    {tokenPre: '(', tokenPost: ')', nestInner: true}\n    , '@()':  {tokenPre: '{', tokenPost: '}', nestInner: true, extraChars: 2}\n    , '@{}':  {tokenPre: '{', tokenPost: '}', nestInner: true, extraChars: 2}\n    , '@[]':  {tokenPre: '[', tokenPost: ']', nestInner: true, extraChars: 2}\n    // note:  no '@()' -- standardize to use single-char '@ ' instead\n    , keyword_args: {tokenPre: '(', tokenPost: ')', nestInner: false, inKeywordArg: true}\n    , keyword_lint: {tokenPre: '(', tokenPost: ')', nestInner: false, inKeywordArg: true}\n\npp._base_parseParenExpression = baseProto.parseParenExpression\npp.parseParenExpression = function () ::\n  try ::\n    return this._base_parseParenExpression()\n  catch (err) ::\n    if (!this.offsidePluginOpts.keyword_blocks) ::\n      throw err\n\n    const stack = this.state.offside\n    const stackTop = stack[stack.length - 1]\n    if (!stackTop || !stackTop.inKeywordArg) ::\n      throw err\n    if (!err.message.startsWith('Unexpected token, expected )')) ::\n      throw err\n\n    this.raise @ stackTop.first.posLastContent, `Keyword with arguments should be followed by a code block. ('::' or '{}')`\n\npp._base_finishToken = baseProto.finishToken\npp.finishToken = function(type, val) ::\n  const state = this.state\n  state.offsideRecentOp = null\n\n  let isKeywordAllowed = !this.isLookahead\n    && tt.dot !== state.type\n\n  if (isKeywordAllowed && state.exprAllowed && state.context.length) ::\n    const tip_context = state.context[state.context.length-1]\n    isKeywordAllowed = !tip_context || !tip_context.isExpr\n\n  if (isKeywordAllowed && tt_offside_keyword_with_args.has(type)) ::\n    const lookahead = this.lookahead()\n\n    if (tt.parenL !== lookahead.type) ::\n      state.offsideNextOp = at_offside.keyword_args\n    else if (lookahead.offsideRecentOp === at_offside['@']) ::\n      state.offsideNextOp = at_offside.keyword_args\n    else if (this.offsidePluginOpts.keyword_blocks) ::\n      if (tt._catch === type || tt._for == type) ::\n        // the following linting approach doesn't work for catch or for statements\n      else ::\n        state.offsideNextOp = at_offside.keyword_lint\n\n    return this._base_finishToken(type, val)\n\n  if (isKeywordAllowed && tt_offside_keyword_with_block.has(type)) ::\n    if (this.offsidePluginOpts.keyword_blocks) ::\n      const lookahead = this.lookahead()\n      if (tt.braceL !== lookahead.type && tt._if !== lookahead.type) ::\n          this.raise @ state.pos, `Keyword \"${type.label}\" should be followed by a code block. ('::' or '{}' or 'if')`\n\n    return this._base_finishToken(type, val)\n\n  if (type === tt.at || type === tt.doubleColon) ::\n    const pos0 = state.start, pos1 = state.pos + 2\n    const str_op = this.input.slice(pos0, pos1).split(/\\s/, 1)[0]\n\n    const op = at_offside[str_op]\n    if (op) :: return this.finishOffsideOp(op)\n\n  if (tt.eof === type) ::\n    if (state.offside.length) ::\n      return this.popOffside()\n\n  return this._base_finishToken(type, val)\n\n\n\npp.offsideBlock = function (op, stackTop) ::\n  let offside_lines = this.offside_lines\n\n  const line0 = this.state.curLine\n  const first = offside_lines[line0]\n  const nestInner = op.nestInner && stackTop && line0 === stackTop.first.line\n  const indent = nestInner ? stackTop.innerIndent : first.indent\n  let line = 1+line0, last = first\n  let innerIndent = offside_lines[line].indent\n\n  while (line < offside_lines.length) ::\n    let cur = offside_lines[line]\n    if (cur.content && indent >= cur.indent) ::\n      break\n\n    line++; last = cur\n    if (innerIndent > cur.indent) ::\n      innerIndent = cur.indent\n\n  // cap to \n  innerIndent = first.indent > innerIndent\n    ? first.indent : innerIndent\n\n  return {op, innerIndent, first, last, nestInner}\n\n\npp.finishOffsideOp = function (op) ::\n  this.state.offsideRecentOp = op\n  const stack = this.state.offside\n  let stackTop = stack[stack.length - 1]\n  if (stackTop && stackTop.inKeywordArg && op.codeBlock) ::\n    this.popOffside()\n    this.state.offsideNextOp = op\n    return\n\n  if (op.extraChars) ::\n    this.state.pos += op.extraChars\n\n  this._base_finishToken(tt_offside[op.tokenPre])\n\n  if (this.isLookahead) :: return\n\n  stackTop = stack[stack.length - 1]\n  let blk = this.offsideBlock(op, stackTop)\n  blk.inKeywordArg = op.inKeywordArg || stackTop && stackTop.inKeywordArg\n  this.state.offside.push(blk)\n\n\npp._base_skipSpace = baseProto.skipSpace\npp.skipSpace = function() ::\n  if (null !== this.state.offsideNextOp) :: return\n\n  const stack = this.state.offside\n  let stackTop\n  if (stack && stack.length) ::\n    stackTop = stack[stack.length-1]\n    this.state.offsidePos = stackTop.last.posLastContent\n  else :: this.state.offsidePos = -1\n\n  try ::\n    this._base_skipSpace()\n    this.state.offsidePos = -1\n  catch (err) ::\n    if (err !== offsideBreakout) :: throw err\n\n\npp._base_readToken = baseProto.readToken\npp.readToken = function(code) ::\n  const offsideNextOp = this.state.offsideNextOp\n  if (null !== offsideNextOp) ::\n    this.state.offsideNextOp = null\n    return this.finishOffsideOp(offsideNextOp)\n\n  else if (this.state.pos === this.state.offsidePos) ::\n    return this.popOffside()\n\n  else ::\n    return this._base_readToken(code)\n\npp.popOffside = function() ::\n  const stack = this.state.offside\n  let stackTop = this.isLookahead\n    ? stack[stack.length-1]\n    : stack.pop()\n  this.state.offsidePos = -1\n\n  const op = stackTop.op\n  const tt_post = tt_offside[op.tokenPost]\n  this._base_finishToken(tt_post)\n  return stackTop\n\n\n\nconst rx_offside = /^([ \\t]*)(.*)$/mg\nfunction parseOffsideIndexMap(input) ::\n  let lines = [null], posLastContent=0, last=['', 0]\n\n  let ans = input.replace @ rx_offside, (match, indent, content, pos) => ::\n    if (!content) ::\n      [indent, posLastContent] = last // blank line; use last valid content as end\n    else ::\n      // valid content; set last to current indent\n      posLastContent = pos + match.length\n      last = [indent, posLastContent]\n\n    lines.push({line: lines.length, posLastContent, indent, content})\n    return ''\n\n  return lines\n\n\n\nconst babel_plugin_id = `babel-plugin-offside--${Date.now()}`\nmodule.exports = exports = (babel) => ::\n  return ::\n    name: babel_plugin_id\n    , manipulateOptions(opts, parserOpts) ::\n        parserOpts.plugins.push('decorators', 'functionBind')\n        parserOpts.offsidePluginOpts = opts.plugins\n          .filter @ plugin => plugin[0] && babel_plugin_id === plugin[0].key\n          .pop()[1]\n\n\nObject.assign @ exports,\n  @{}\n    hookBabylon,\n    parseOffsideIndexMap,\n\n"]}