const babylon = require('babylon');
const tt = babylon.tokTypes;

var _g_offsidePluginOpts;
const default_offsidePluginOpts = { keyword_blocks: true };

const _base_module_parse = babylon.parse;
babylon.parse = (input, options) => {
  _g_offsidePluginOpts = options ? options.offsidePluginOpts : undefined;
  return _base_module_parse(input, options);
};

const Parser = hookBabylon();
const baseProto = Parser.prototype;
const pp = Parser.prototype = Object.create(baseProto);

function hookBabylon() {
  // abuse Babylon token updateContext callback extract
  // the reference to Parser

  let Parser;
  let tgt_patch = babylon.tokTypes.braceL;
  let fn_updateContext = tgt_patch.updateContext;
  tgt_patch.updateContext = function (prevType) {
    tgt_patch.updateContext = fn_updateContext;
    Parser = this.constructor;
  };

  babylon.parse('{}');
  if (!Parser) {
    throw new Error("Failed to hook Babylon Parser");
  }
  return Parser;
}

pp._base_parse = baseProto.parse;
pp.parse = function () {
  this.initOffside();
  return this._base_parse();
};

class OffsideBreakout extends Error {}
const offsideBreakout = new OffsideBreakout();

pp.initOffside = function () {
  this.state.offside = [];
  this.state.offsideNextOp = null;
  this.offside_lines = parseOffsideIndexMap(this.input);
  this.offsidePluginOpts = _g_offsidePluginOpts || {};
  _g_offsidePluginOpts = null;

  this.state._pos = this.state.pos;
  Object.defineProperty(this.state, 'pos', { enumerable: true,
    get() {
      return this._pos;
    }, set(pos) {
      // interrupt skipSpace algorithm when we hit our position 'breakpoint'
      let offPos = this.offsidePos;
      if (offPos >= 0 && pos > offPos) {
        throw offsideBreakout;
      }

      this._pos = pos;
    } });
};

let tt_offside_keyword_with_args = new Set([tt._if, tt._while, tt._for, tt._catch, tt._switch]);

let tt_offside_keyword_lookahead_skip = new Set([tt.parenL, tt.colon, tt.comma, tt.dot]);

let at_offside = { '::': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: false, codeBlock: true },
  '::@': { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: false, extraChars: 1 },
  '::()': { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: false, extraChars: 2 },
  '::{}': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: false, extraChars: 2 },
  '::[]': { tokenPre: tt.bracketL, tokenPost: tt.bracketR, nestInner: false, extraChars: 2 },
  '@': { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: true, keywordBlock: true },
  '@()': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: true, extraChars: 2 },
  '@{}': { tokenPre: tt.braceL, tokenPost: tt.braceR, nestInner: true, extraChars: 2 },
  '@[]': { tokenPre: tt.bracketL, tokenPost: tt.bracketR, nestInner: true, extraChars: 2 }
  // note:  no '@()' -- standardize to use single-char '@ ' instead
  , keyword_args: { tokenPre: tt.parenL, tokenPost: tt.parenR, nestInner: false, inKeywordArg: true } };

pp._base_finishToken = baseProto.finishToken;
pp.finishToken = function (type, val) {
  const state = this.state;

  if (tt_offside_keyword_with_args.has(type)) {
    let isKeywordAllowed = !this.isLookahead && tt.dot !== state.type;

    state.offsideRecentKeyword = isKeywordAllowed;
    if (!isKeywordAllowed) {
      return this._base_finishToken(type, val);
    }

    const lookahead = this.lookahead();

    if (!tt_offside_keyword_lookahead_skip.has(lookahead.type)) {
      state.offsideNextOp = at_offside.keyword_args;
    }

    return this._base_finishToken(type, val);
  }

  const recentKeyword = state.offsideRecentKeyword;
  state.offsideRecentKeyword = null;
  if (type === tt.at || type === tt.doubleColon) {
    const pos0 = state.start,
          pos1 = state.pos + 2;
    const str_op = this.input.slice(pos0, pos1).split(/\s/, 1)[0];

    let op = at_offside[str_op];
    if (op.keywordBlock && recentKeyword && tt_offside_keyword_with_args.has(state.type)) {
      op = at_offside.keyword_args;
    }
    if (op) {
      return this.finishOffsideOp(op);
    }
  }

  if (tt.eof === type) {
    if (state.offside.length) {
      return this.popOffside();
    }
  }

  return this._base_finishToken(type, val);
};

pp.offsideBlock = function (op, stackTop, recentKeywordTop) {
  let offside_lines = this.offside_lines;

  const line0 = this.state.curLine;
  const first = offside_lines[line0];
  const nestInner = op.nestInner && stackTop && line0 === stackTop.first.line;
  const indent = recentKeywordTop ? recentKeywordTop.first.indent : nestInner ? stackTop.innerIndent : first.indent;
  let line = 1 + line0,
      last = first;
  const innerLine = offside_lines[line];
  let innerIndent = innerLine ? innerLine.indent : '';

  while (line < offside_lines.length) {
    let cur = offside_lines[line];
    if (cur.content && indent >= cur.indent) {
      break;
    }

    line++;last = cur;
    if (innerIndent > cur.indent) {
      innerIndent = cur.indent;
    }
  }

  // cap to 
  innerIndent = first.indent > innerIndent ? first.indent : innerIndent;

  return { op, innerIndent, first, last, nestInner, recentKeywordTop };
};

pp.finishOffsideOp = function (op) {
  const stack = this.state.offside;
  let stackTop = stack[stack.length - 1];
  let recentKeywordTop;
  if (op.codeBlock) {
    if (stackTop && stackTop.inKeywordArg) {
      this.popOffside();
      this.state.offsideNextOp = op;
      this.state.offsideRecentTop = stackTop;
      return;
    }

    recentKeywordTop = this.state.offsideRecentTop;
    this.state.offsideRecentTop = null;
  }

  if (op.extraChars) {
    this.state.pos += op.extraChars;
  }

  this._base_finishToken(op.tokenPre);

  if (this.isLookahead) {
    return;
  }

  stackTop = stack[stack.length - 1];
  let blk = this.offsideBlock(op, stackTop, recentKeywordTop);
  blk.inKeywordArg = op.inKeywordArg || stackTop && stackTop.inKeywordArg;
  this.state.offside.push(blk);
};

pp._base_skipSpace = baseProto.skipSpace;
pp.skipSpace = function () {
  if (null !== this.state.offsideNextOp) {
    return;
  }

  const stack = this.state.offside;
  let stackTop;
  if (stack && stack.length) {
    stackTop = stack[stack.length - 1];
    this.state.offsidePos = stackTop.last.posLastContent;
  } else {
    this.state.offsidePos = -1;
  }

  try {
    this._base_skipSpace();
    this.state.offsidePos = -1;
  } catch (err) {
    if (err !== offsideBreakout) {
      throw err;
    }
  }
};

pp._base_readToken = baseProto.readToken;
pp.readToken = function (code) {
  const offsideNextOp = this.state.offsideNextOp;
  if (null !== offsideNextOp) {
    this.state.offsideNextOp = null;
    return this.finishOffsideOp(offsideNextOp);
  } else if (this.state.pos === this.state.offsidePos) {
    return this.popOffside();
  } else {
    return this._base_readToken(code);
  }
};

pp.popOffside = function () {
  const stack = this.state.offside;
  let stackTop = this.isLookahead ? stack[stack.length - 1] : stack.pop();
  this.state.offsidePos = -1;

  this._base_finishToken(stackTop.op.tokenPost);
  return stackTop;
};

const rx_offside = /^([ \t]*)(.*)$/mg;
function parseOffsideIndexMap(input) {
  let lines = [null],
      posLastContent = 0,
      last = ['', 0];

  let ans = input.replace(rx_offside, (match, indent, content, pos) => {
    if (!content) {
      [indent, posLastContent] = last; // blank line; use last valid content as end
    } else {
        // valid content; set last to current indent
        posLastContent = pos + match.length;
        last = [indent, posLastContent];
      }

    lines.push({ line: lines.length, posLastContent, indent, content });
    return '';
  });

  return lines;
}

const keyword_block_parents = { IfStatement: 'if',
  ForStatement: 'for',
  ForOfStatement: 'for',
  WhileStatement: 'while',
  DoWhileStatement: 'do-while' };
const lint_keyword_block_parents = new Set(Object.keys(keyword_block_parents));

const babel_plugin_id = `babel-plugin-offside--${Date.now()}`;
module.exports = exports = babel => {
  return {
    name: babel_plugin_id,
    pre(state) {
      this.opts = Object.assign({}, default_offsidePluginOpts, this.opts);
    }, manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push('decorators', 'functionBind');
      const offsidePluginOpts = opts.plugins.filter(plugin => plugin[0] && babel_plugin_id === plugin[0].key && plugin[1]).map(plugin => plugin[1]).pop();
      parserOpts.offsidePluginOpts = offsidePluginOpts || default_offsidePluginOpts;
    }, visitor: {
      ExpressionStatement(path) {
        if (!this.opts.keyword_blocks) {
          return;
        }
        if (!lint_keyword_block_parents.has(path.parent.type)) {
          return;
        }

        let keyword = keyword_block_parents[path.parent.type];
        if ('if' === keyword && path.node === path.parent.alternate) {
          keyword = 'else'; // fixup if/else combined parent condition
        }throw path.buildCodeFrameError(`Keyword '${keyword}' should be followed by a block statement using '::' or matching '{' / '}'. \n` + `    (From 'keyword_blocks' enforcement option of babel-plugin-offside)`);
      } } };
};

Object.assign(exports, {
  hookBabylon,
  parseOffsideIndexMap });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2NvZGUvaW5kZXguanMiXSwibmFtZXMiOlsiYmFieWxvbiIsInJlcXVpcmUiLCJ0dCIsInRva1R5cGVzIiwiX2dfb2Zmc2lkZVBsdWdpbk9wdHMiLCJkZWZhdWx0X29mZnNpZGVQbHVnaW5PcHRzIiwia2V5d29yZF9ibG9ja3MiLCJfYmFzZV9tb2R1bGVfcGFyc2UiLCJwYXJzZSIsImlucHV0Iiwib3B0aW9ucyIsIm9mZnNpZGVQbHVnaW5PcHRzIiwidW5kZWZpbmVkIiwiUGFyc2VyIiwiaG9va0JhYnlsb24iLCJiYXNlUHJvdG8iLCJwcm90b3R5cGUiLCJwcCIsIk9iamVjdCIsImNyZWF0ZSIsInRndF9wYXRjaCIsImJyYWNlTCIsImZuX3VwZGF0ZUNvbnRleHQiLCJ1cGRhdGVDb250ZXh0IiwicHJldlR5cGUiLCJjb25zdHJ1Y3RvciIsIkVycm9yIiwiX2Jhc2VfcGFyc2UiLCJpbml0T2Zmc2lkZSIsIk9mZnNpZGVCcmVha291dCIsIm9mZnNpZGVCcmVha291dCIsInN0YXRlIiwib2Zmc2lkZSIsIm9mZnNpZGVOZXh0T3AiLCJvZmZzaWRlX2xpbmVzIiwicGFyc2VPZmZzaWRlSW5kZXhNYXAiLCJfcG9zIiwicG9zIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2V0Iiwib2ZmUG9zIiwib2Zmc2lkZVBvcyIsInR0X29mZnNpZGVfa2V5d29yZF93aXRoX2FyZ3MiLCJTZXQiLCJfaWYiLCJfd2hpbGUiLCJfZm9yIiwiX2NhdGNoIiwiX3N3aXRjaCIsInR0X29mZnNpZGVfa2V5d29yZF9sb29rYWhlYWRfc2tpcCIsInBhcmVuTCIsImNvbG9uIiwiY29tbWEiLCJkb3QiLCJhdF9vZmZzaWRlIiwidG9rZW5QcmUiLCJ0b2tlblBvc3QiLCJicmFjZVIiLCJuZXN0SW5uZXIiLCJjb2RlQmxvY2siLCJwYXJlblIiLCJleHRyYUNoYXJzIiwiYnJhY2tldEwiLCJicmFja2V0UiIsImtleXdvcmRCbG9jayIsImtleXdvcmRfYXJncyIsImluS2V5d29yZEFyZyIsIl9iYXNlX2ZpbmlzaFRva2VuIiwiZmluaXNoVG9rZW4iLCJ0eXBlIiwidmFsIiwiaGFzIiwiaXNLZXl3b3JkQWxsb3dlZCIsImlzTG9va2FoZWFkIiwib2Zmc2lkZVJlY2VudEtleXdvcmQiLCJsb29rYWhlYWQiLCJyZWNlbnRLZXl3b3JkIiwiYXQiLCJkb3VibGVDb2xvbiIsInBvczAiLCJzdGFydCIsInBvczEiLCJzdHJfb3AiLCJzbGljZSIsInNwbGl0Iiwib3AiLCJmaW5pc2hPZmZzaWRlT3AiLCJlb2YiLCJsZW5ndGgiLCJwb3BPZmZzaWRlIiwib2Zmc2lkZUJsb2NrIiwic3RhY2tUb3AiLCJyZWNlbnRLZXl3b3JkVG9wIiwibGluZTAiLCJjdXJMaW5lIiwiZmlyc3QiLCJsaW5lIiwiaW5kZW50IiwiaW5uZXJJbmRlbnQiLCJsYXN0IiwiaW5uZXJMaW5lIiwiY3VyIiwiY29udGVudCIsInN0YWNrIiwib2Zmc2lkZVJlY2VudFRvcCIsImJsayIsInB1c2giLCJfYmFzZV9za2lwU3BhY2UiLCJza2lwU3BhY2UiLCJwb3NMYXN0Q29udGVudCIsImVyciIsIl9iYXNlX3JlYWRUb2tlbiIsInJlYWRUb2tlbiIsImNvZGUiLCJwb3AiLCJyeF9vZmZzaWRlIiwibGluZXMiLCJhbnMiLCJyZXBsYWNlIiwibWF0Y2giLCJrZXl3b3JkX2Jsb2NrX3BhcmVudHMiLCJJZlN0YXRlbWVudCIsIkZvclN0YXRlbWVudCIsIkZvck9mU3RhdGVtZW50IiwiV2hpbGVTdGF0ZW1lbnQiLCJEb1doaWxlU3RhdGVtZW50IiwibGludF9rZXl3b3JkX2Jsb2NrX3BhcmVudHMiLCJrZXlzIiwiYmFiZWxfcGx1Z2luX2lkIiwiRGF0ZSIsIm5vdyIsIm1vZHVsZSIsImV4cG9ydHMiLCJiYWJlbCIsIm5hbWUiLCJwcmUiLCJvcHRzIiwiYXNzaWduIiwibWFuaXB1bGF0ZU9wdGlvbnMiLCJwYXJzZXJPcHRzIiwicGx1Z2lucyIsImZpbHRlciIsInBsdWdpbiIsImtleSIsIm1hcCIsInZpc2l0b3IiLCJFeHByZXNzaW9uU3RhdGVtZW50IiwicGF0aCIsInBhcmVudCIsImtleXdvcmQiLCJub2RlIiwiYWx0ZXJuYXRlIiwiYnVpbGRDb2RlRnJhbWVFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUEsVUFBVUMsUUFBUSxTQUFSLENBQWhCO0FBQ0EsTUFBTUMsS0FBS0YsUUFBUUcsUUFBbkI7O0FBRUEsSUFBSUMsb0JBQUo7QUFDQSxNQUFNQyw0QkFDSixFQUFJQyxnQkFBZ0IsSUFBcEIsRUFERjs7QUFHQSxNQUFNQyxxQkFBcUJQLFFBQVFRLEtBQW5DO0FBQ0FSLFFBQVFRLEtBQVIsR0FBZ0IsQ0FBQ0MsS0FBRCxFQUFRQyxPQUFSLEtBQW9CO0FBQ2xDTix5QkFBdUJNLFVBQVVBLFFBQVFDLGlCQUFsQixHQUFzQ0MsU0FBN0Q7QUFDQSxTQUFPTCxtQkFBbUJFLEtBQW5CLEVBQTBCQyxPQUExQixDQUFQO0FBQXlDLENBRjNDOztBQUlBLE1BQU1HLFNBQVNDLGFBQWY7QUFDQSxNQUFNQyxZQUFZRixPQUFPRyxTQUF6QjtBQUNBLE1BQU1DLEtBQUtKLE9BQU9HLFNBQVAsR0FBbUJFLE9BQU9DLE1BQVAsQ0FBY0osU0FBZCxDQUE5Qjs7QUFFQSxTQUFTRCxXQUFULEdBQXVCO0FBQ3JCO0FBQ0E7O0FBRUEsTUFBSUQsTUFBSjtBQUNBLE1BQUlPLFlBQVlwQixRQUFRRyxRQUFSLENBQWlCa0IsTUFBakM7QUFDQSxNQUFJQyxtQkFBbUJGLFVBQVVHLGFBQWpDO0FBQ0FILFlBQVVHLGFBQVYsR0FBMEIsVUFBVUMsUUFBVixFQUFvQjtBQUM1Q0osY0FBVUcsYUFBVixHQUEwQkQsZ0JBQTFCO0FBQ0FULGFBQVMsS0FBS1ksV0FBZDtBQUF5QixHQUYzQjs7QUFJQXpCLFVBQVFRLEtBQVIsQ0FBYyxJQUFkO0FBQ0EsTUFBSSxDQUFDSyxNQUFMLEVBQWE7QUFDWCxVQUFNLElBQUlhLEtBQUosQ0FBWSwrQkFBWixDQUFOO0FBQWlEO0FBQ25ELFNBQU9iLE1BQVA7QUFBYTs7QUFJZkksR0FBR1UsV0FBSCxHQUFpQlosVUFBVVAs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QVYsQ0FEMkQsQ0FDMUM7QUFBMEMsU0FFN0QsTUFBTUYsS0FBS0ssbUJBQUwsQ0FDSCxZQUFXSCxPQUFRLGdGQUFwQixHQUNDLHdFQUZHLENBQU47QUFFMEUsT0FYckUsRUFiTixFQUFQO0FBd0JrRixDQXpCcEY7O0FBNEJBckksT0FBT3lILE1BQVAsQ0FBZ0JMLE9BQWhCLEVBQ0U7QUFDRXhILGFBREY7QUFFRXFCLHNCQUZGLEVBREYiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBiYWJ5bG9uID0gcmVxdWlyZSgnYmFieWxvbicpXG5jb25zdCB0dCA9IGJhYnlsb24udG9rVHlwZXNcblxudmFyIF9nX29mZnNpZGVQbHVnaW5PcHRzXG5jb25zdCBkZWZhdWx0X29mZnNpZGVQbHVnaW5PcHRzID1cbiAgQHt9IGtleXdvcmRfYmxvY2tzOiB0cnVlXG5cbmNvbnN0IF9iYXNlX21vZHVsZV9wYXJzZSA9IGJhYnlsb24ucGFyc2VcbmJhYnlsb24ucGFyc2UgPSAoaW5wdXQsIG9wdGlvbnMpID0+IDo6XG4gIF9nX29mZnNpZGVQbHVnaW5PcHRzID0gb3B0aW9ucyA/IG9wdGlvbnMub2Zmc2lkZVBsdWdpbk9wdHMgOiB1bmRlZmluZWRcbiAgcmV0dXJuIF9iYXNlX21vZHVsZV9wYXJzZShpbnB1dCwgb3B0aW9ucylcblxuY29uc3QgUGFyc2VyID0gaG9va0JhYnlsb24oKVxuY29uc3QgYmFzZVByb3RvID0gUGFyc2VyLnByb3RvdHlwZVxuY29uc3QgcHAgPSBQYXJzZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvdG8pXG5cbmZ1bmN0aW9uIGhvb2tCYWJ5bG9uKCkgOjpcbiAgLy8gYWJ1c2UgQmFieWxvbiB0b2tlbiB1cGRhdGVDb250ZXh0IGNhbGxiYWNrIGV4dHJhY3RcbiAgLy8gdGhlIHJlZmVyZW5jZSB0byBQYXJzZXJcblxuICBsZXQgUGFyc2VyXG4gIGxldCB0Z3RfcGF0Y2ggPSBiYWJ5bG9uLnRva1R5cGVzLmJyYWNlTFxuICBsZXQgZm5fdXBkYXRlQ29udGV4dCA9IHRndF9wYXRjaC51cGRhdGVDb250ZXh0XG4gIHRndF9wYXRjaC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKHByZXZUeXBlKSA6OlxuICAgIHRndF9wYXRjaC51cGRhdGVDb250ZXh0ID0gZm5fdXBkYXRlQ29udGV4dFxuICAgIFBhcnNlciA9IHRoaXMuY29uc3RydWN0b3JcblxuICBiYWJ5bG9uLnBhcnNlKCd7fScpXG4gIGlmICghUGFyc2VyKSA6OlxuICAgIHRocm93IG5ldyBFcnJvciBAIFwiRmFpbGVkIHRvIGhvb2sgQmFieWxvbiBQYXJzZXJcIlxuICByZXR1cm4gUGFyc2VyXG5cblxuXG5wcC5fYmFzZV9wYXJzZSA9IGJhc2VQcm90by5wYXJzZVxucHAucGFyc2UgPSBmdW5jdGlvbigpIDo6XG4gIHRoaXMuaW5pdE9mZnNpZGUoKVxuICByZXR1cm4gdGhpcy5fYmFzZV9wYXJzZSgpXG5cblxuY2xhc3MgT2Zmc2lkZUJyZWFrb3V0IGV4dGVuZHMgRXJyb3Ige31cbmNvbnN0IG9mZnNpZGVCcmVha291dCA9IG5ldyBPZmZzaWRlQnJlYWtvdXQoKVxuXG5wcC5pbml0T2Zmc2lkZSA9IGZ1bmN0aW9uKCkgOjpcbiAgdGhpcy5zdGF0ZS5vZmZzaWRlID0gW11cbiAgdGhpcy5zdGF0ZS5vZmZzaWRlTmV4dE9wID0gbnVsbFxuICB0aGlzLm9mZnNpZGVfbGluZXMgPSBwYXJzZU9mZnNpZGVJbmRleE1hcCh0aGlzLmlucHV0KVxuICB0aGlzLm9mZnNpZGVQbHVnaW5PcHRzID0gX2dfb2Zmc2lkZVBsdWdpbk9wdHMgfHwge31cbiAgX2dfb2Zmc2lkZVBsdWdpbk9wdHMgPSBudWxsXG5cbiAgdGhpcy5zdGF0ZS5fcG9zID0gdGhpcy5zdGF0ZS5wb3NcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5IEAgdGhpcy5zdGF0ZSwgJ3BvcycsXG4gICAgQHt9IGVudW1lcmFibGU6IHRydWVcbiAgICAgICwgZ2V0KCkgOjogcmV0dXJuIHRoaXMuX3Bvc1xuICAgICAgLCBzZXQocG9zKSA6OlxuICAgICAgICAgIC8vIGludGVycnVwdCBza2lwU3BhY2UgYWxnb3JpdGhtIHdoZW4gd2UgaGl0IG91ciBwb3NpdGlvbiAnYnJlYWtwb2ludCdcbiAgICAgICAgICBsZXQgb2ZmUG9zID0gdGhpcy5vZmZzaWRlUG9zXG4gICAgICAgICAgaWYgKG9mZlBvcz49MCAmJiAocG9zID4gb2ZmUG9zKSkgOjpcbiAgICAgICAgICAgIHRocm93IG9mZnNpZGVCcmVha291dFxuXG4gICAgICAgICAgdGhpcy5fcG9zID0gcG9zXG5cblxubGV0IHR0X29mZnNpZGVfa2V5d29yZF93aXRoX2FyZ3MgPSBuZXcgU2V0IEBcbiAgQFtdIHR0Ll9pZiwgdHQuX3doaWxlLCB0dC5fZm9yXG4gICAgLCB0dC5fY2F0Y2gsIHR0Ll9zd2l0Y2hcblxubGV0IHR0X29mZnNpZGVfa2V5d29yZF9sb29rYWhlYWRfc2tpcCA9IG5ldyBTZXQgQFxuICBAW10gdHQucGFyZW5MLCB0dC5jb2xvbiwgdHQuY29tbWEsIHR0LmRvdFxuXG5sZXQgYXRfb2Zmc2lkZSA9XG4gIEB7fSAnOjonOiAgIHt0b2tlblByZTogdHQuYnJhY2VMLCB0b2tlblBvc3Q6IHR0LmJyYWNlUiwgbmVzdElubmVyOiBmYWxzZSwgY29kZUJsb2NrOiB0cnVlfVxuICAgICwgJzo6QCc6ICB7dG9rZW5QcmU6IHR0LnBhcmVuTCwgdG9rZW5Qb3N0OiB0dC5wYXJlblIsIG5lc3RJbm5lcjogZmFsc2UsIGV4dHJhQ2hhcnM6IDF9XG4gICAgLCAnOjooKSc6IHt0b2tlblByZTogdHQucGFyZW5MLCB0b2tlblBvc3Q6IHR0LnBhcmVuUiwgbmVzdElubmVyOiBmYWxzZSwgZXh0cmFDaGFyczogMn1cbiAgICAsICc6Ont9Jzoge3Rva2VuUHJlOiB0dC5icmFjZUwsIHRva2VuUG9zdDogdHQuYnJhY2VSLCBuZXN0SW5uZXI6IGZhbHNlLCBleHRyYUNoYXJzOiAyfVxuICAgICwgJzo6W10nOiB7dG9rZW5QcmU6IHR0LmJyYWNrZXRMLCB0b2tlblBvc3Q6IHR0LmJyYWNrZXRSLCBuZXN0SW5uZXI6IGZhbHNlLCBleHRyYUNoYXJzOiAyfVxuICAgICwgJ0AnOiAgICB7dG9rZW5QcmU6IHR0LnBhcmVuTCwgdG9rZW5Qb3N0OiB0dC5wYXJlblIsIG5lc3RJbm5lcjogdHJ1ZSwga2V5d29yZEJsb2NrOiB0cnVlfVxuICAgICwgJ0AoKSc6ICB7dG9rZW5QcmU6IHR0LmJyYWNlTCwgdG9rZW5Qb3N0OiB0dC5icmFjZVIsIG5lc3RJbm5lcjogdHJ1ZSwgZXh0cmFDaGFyczogMn1cbiAgICAsICdAe30nOiAge3Rva2VuUHJlOiB0dC5icmFjZUwsIHRva2VuUG9zdDogdHQuYnJhY2VSLCBuZXN0SW5uZXI6IHRydWUsIGV4dHJhQ2hhcnM6IDJ9XG4gICAgLCAnQFtdJzogIHt0b2tlblByZTogdHQuYnJhY2tldEwsIHRva2VuUG9zdDogdHQuYnJhY2tldFIsIG5lc3RJbm5lcjogdHJ1ZSwgZXh0cmFDaGFyczogMn1cbiAgICAvLyBub3RlOiAgbm8gJ0AoKScgLS0gc3RhbmRhcmRpemUgdG8gdXNlIHNpbmdsZS1jaGFyICdAICcgaW5zdGVhZFxuICAgICwga2V5d29yZF9hcmdzOiB7dG9rZW5QcmU6IHR0LnBhcmVuTCwgdG9rZW5Qb3N0OiB0dC5wYXJlblIsIG5lc3RJbm5lcjogZmFsc2UsIGluS2V5d29yZEFyZzogdHJ1ZX1cblxucHAuX2Jhc2VfZmluaXNoVG9rZW4gPSBiYXNlUHJvdG8uZmluaXNoVG9rZW5cbnBwLmZpbmlzaFRva2VuID0gZnVuY3Rpb24odHlwZSwgdmFsKSA6OlxuICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGVcblxuICBpZiAodHRfb2Zmc2lkZV9rZXl3b3JkX3dpdGhfYXJncy5oYXModHlwZSkpIDo6XG4gICAgbGV0IGlzS2V5d29yZEFsbG93ZWQgPSAhdGhpcy5pc0xvb2thaGVhZFxuICAgICAgJiYgdHQuZG90ICE9PSBzdGF0ZS50eXBlXG5cbiAgICBzdGF0ZS5vZmZzaWRlUmVjZW50S2V5d29yZCA9IGlzS2V5d29yZEFsbG93ZWRcbiAgICBpZiAoIWlzS2V5d29yZEFsbG93ZWQpIDo6XG4gICAgICByZXR1cm4gdGhpcy5fYmFzZV9maW5pc2hUb2tlbih0eXBlLCB2YWwpXG5cbiAgICBjb25zdCBsb29rYWhlYWQgPSB0aGlzLmxvb2thaGVhZCgpXG5cbiAgICBpZiAoIXR0X29mZnNpZGVfa2V5d29yZF9sb29rYWhlYWRfc2tpcC5oYXMobG9va2FoZWFkLnR5cGUpKSA6OlxuICAgICAgc3RhdGUub2Zmc2lkZU5leHRPcCA9IGF0X29mZnNpZGUua2V5d29yZF9hcmdzXG5cbiAgICByZXR1cm4gdGhpcy5fYmFzZV9maW5pc2hUb2tlbih0eXBlLCB2YWwpXG5cbiAgY29uc3QgcmVjZW50S2V5d29yZCA9IHN0YXRlLm9mZnNpZGVSZWNlbnRLZXl3b3JkXG4gIHN0YXRlLm9mZnNpZGVSZWNlbnRLZXl3b3JkID0gbnVsbFxuICBpZiAodHlwZSA9PT0gdHQuYXQgfHwgdHlwZSA9PT0gdHQuZG91YmxlQ29sb24pIDo6XG4gICAgY29uc3QgcG9zMCA9IHN0YXRlLnN0YXJ0LCBwb3MxID0gc3RhdGUucG9zICsgMlxuICAgIGNvbnN0IHN0cl9vcCA9IHRoaXMuaW5wdXQuc2xpY2UocG9zMCwgcG9zMSkuc3BsaXQoL1xccy8sIDEpWzBdXG5cbiAgICBsZXQgb3AgPSBhdF9vZmZzaWRlW3N0cl9vcF1cbiAgICBpZiAob3Aua2V5d29yZEJsb2NrICYmIHJlY2VudEtleXdvcmQgJiYgdHRfb2Zmc2lkZV9rZXl3b3JkX3dpdGhfYXJncy5oYXMoc3RhdGUudHlwZSkpIDo6XG4gICAgICBvcCA9IGF0X29mZnNpZGUua2V5d29yZF9hcmdzXG4gICAgaWYgKG9wKSA6OiByZXR1cm4gdGhpcy5maW5pc2hPZmZzaWRlT3Aob3ApXG5cbiAgaWYgKHR0LmVvZiA9PT0gdHlwZSkgOjpcbiAgICBpZiAoc3RhdGUub2Zmc2lkZS5sZW5ndGgpIDo6XG4gICAgICByZXR1cm4gdGhpcy5wb3BPZmZzaWRlKClcblxuICByZXR1cm4gdGhpcy5fYmFzZV9maW5pc2hUb2tlbih0eXBlLCB2YWwpXG5cblxuXG5wcC5vZmZzaWRlQmxvY2sgPSBmdW5jdGlvbiAob3AsIHN0YWNrVG9wLCByZWNlbnRLZXl3b3JkVG9wKSA6OlxuICBsZXQgb2Zmc2lkZV9saW5lcyA9IHRoaXMub2Zmc2lkZV9saW5lc1xuXG4gIGNvbnN0IGxpbmUwID0gdGhpcy5zdGF0ZS5jdXJMaW5lXG4gIGNvbnN0IGZpcnN0ID0gb2Zmc2lkZV9saW5lc1tsaW5lMF1cbiAgY29uc3QgbmVzdElubmVyID0gb3AubmVzdElubmVyICYmIHN0YWNrVG9wICYmIGxpbmUwID09PSBzdGFja1RvcC5maXJzdC5saW5lXG4gIGNvbnN0IGluZGVudCA9IHJlY2VudEtleXdvcmRUb3AgPyByZWNlbnRLZXl3b3JkVG9wLmZpcnN0LmluZGVudFxuICAgIDogbmVzdElubmVyID8gc3RhY2tUb3AuaW5uZXJJbmRlbnQgOiBmaXJzdC5pbmRlbnRcbiAgbGV0IGxpbmUgPSAxK2xpbmUwLCBsYXN0ID0gZmlyc3RcbiAgY29uc3QgaW5uZXJMaW5lID0gb2Zmc2lkZV9saW5lc1tsaW5lXVxuICBsZXQgaW5uZXJJbmRlbnQgPSBpbm5lckxpbmUgPyBpbm5lckxpbmUuaW5kZW50IDogJydcblxuICB3aGlsZSAobGluZSA8IG9mZnNpZGVfbGluZXMubGVuZ3RoKSA6OlxuICAgIGxldCBjdXIgPSBvZmZzaWRlX2xpbmVzW2xpbmVdXG4gICAgaWYgKGN1ci5jb250ZW50ICYmIGluZGVudCA+PSBjdXIuaW5kZW50KSA6OlxuICAgICAgYnJlYWtcblxuICAgIGxpbmUrKzsgbGFzdCA9IGN1clxuICAgIGlmIChpbm5lckluZGVudCA+IGN1ci5pbmRlbnQpIDo6XG4gICAgICBpbm5lckluZGVudCA9IGN1ci5pbmRlbnRcblxuICAvLyBjYXAgdG8gXG4gIGlubmVySW5kZW50ID0gZmlyc3QuaW5kZW50ID4gaW5uZXJJbmRlbnRcbiAgICA/IGZpcnN0LmluZGVudCA6IGlubmVySW5kZW50XG5cbiAgcmV0dXJuIHtvcCwgaW5uZXJJbmRlbnQsIGZpcnN0LCBsYXN0LCBuZXN0SW5uZXIsIHJlY2VudEtleXdvcmRUb3B9XG5cblxuXG5wcC5maW5pc2hPZmZzaWRlT3AgPSBmdW5jdGlvbiAob3ApIDo6XG4gIGNvbnN0IHN0YWNrID0gdGhpcy5zdGF0ZS5vZmZzaWRlXG4gIGxldCBzdGFja1RvcCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXG4gIGxldCByZWNlbnRLZXl3b3JkVG9wXG4gIGlmIChvcC5jb2RlQmxvY2spIDo6XG4gICAgaWYgKHN0YWNrVG9wICYmIHN0YWNrVG9wLmluS2V5d29yZEFyZykgOjpcbiAgICAgIHRoaXMucG9wT2Zmc2lkZSgpXG4gICAgICB0aGlzLnN0YXRlLm9mZnNpZGVOZXh0T3AgPSBvcFxuICAgICAgdGhpcy5zdGF0ZS5vZmZzaWRlUmVjZW50VG9wID0gc3RhY2tUb3BcbiAgICAgIHJldHVyblxuXG4gICAgcmVjZW50S2V5d29yZFRvcCA9IHRoaXMuc3RhdGUub2Zmc2lkZVJlY2VudFRvcFxuICAgIHRoaXMuc3RhdGUub2Zmc2lkZVJlY2VudFRvcCA9IG51bGxcblxuICBpZiAob3AuZXh0cmFDaGFycykgOjpcbiAgICB0aGlzLnN0YXRlLnBvcyArPSBvcC5leHRyYUNoYXJzXG5cbiAgdGhpcy5fYmFzZV9maW5pc2hUb2tlbihvcC50b2tlblByZSlcblxuICBpZiAodGhpcy5pc0xvb2thaGVhZCkgOjogcmV0dXJuXG5cbiAgc3RhY2tUb3AgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXVxuICBsZXQgYmxrID0gdGhpcy5vZmZzaWRlQmxvY2sob3AsIHN0YWNrVG9wLCByZWNlbnRLZXl3b3JkVG9wKVxuICBibGsuaW5LZXl3b3JkQXJnID0gb3AuaW5LZXl3b3JkQXJnIHx8IHN0YWNrVG9wICYmIHN0YWNrVG9wLmluS2V5d29yZEFyZ1xuICB0aGlzLnN0YXRlLm9mZnNpZGUucHVzaChibGspXG5cblxucHAuX2Jhc2Vfc2tpcFNwYWNlID0gYmFzZVByb3RvLnNraXBTcGFjZVxucHAuc2tpcFNwYWNlID0gZnVuY3Rpb24oKSA6OlxuICBpZiAobnVsbCAhPT0gdGhpcy5zdGF0ZS5vZmZzaWRlTmV4dE9wKSA6OiByZXR1cm5cblxuICBjb25zdCBzdGFjayA9IHRoaXMuc3RhdGUub2Zmc2lkZVxuICBsZXQgc3RhY2tUb3BcbiAgaWYgKHN0YWNrICYmIHN0YWNrLmxlbmd0aCkgOjpcbiAgICBzdGFja1RvcCA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXVxuICAgIHRoaXMuc3RhdGUub2Zmc2lkZVBvcyA9IHN0YWNrVG9wLmxhc3QucG9zTGFzdENvbnRlbnRcbiAgZWxzZSA6OiB0aGlzLnN0YXRlLm9mZnNpZGVQb3MgPSAtMVxuXG4gIHRyeSA6OlxuICAgIHRoaXMuX2Jhc2Vfc2tpcFNwYWNlKClcbiAgICB0aGlzLnN0YXRlLm9mZnNpZGVQb3MgPSAtMVxuICBjYXRjaCAoZXJyKSA6OlxuICAgIGlmIChlcnIgIT09IG9mZnNpZGVCcmVha291dCkgOjogdGhyb3cgZXJyXG5cblxucHAuX2Jhc2VfcmVhZFRva2VuID0gYmFzZVByb3RvLnJlYWRUb2tlblxucHAucmVhZFRva2VuID0gZnVuY3Rpb24oY29kZSkgOjpcbiAgY29uc3Qgb2Zmc2lkZU5leHRPcCA9IHRoaXMuc3RhdGUub2Zmc2lkZU5leHRPcFxuICBpZiAobnVsbCAhPT0gb2Zmc2lkZU5leHRPcCkgOjpcbiAgICB0aGlzLnN0YXRlLm9mZnNpZGVOZXh0T3AgPSBudWxsXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT2Zmc2lkZU9wKG9mZnNpZGVOZXh0T3ApXG5cbiAgZWxzZSBpZiAodGhpcy5zdGF0ZS5wb3MgPT09IHRoaXMuc3RhdGUub2Zmc2lkZVBvcykgOjpcbiAgICByZXR1cm4gdGhpcy5wb3BPZmZzaWRlKClcblxuICBlbHNlIDo6XG4gICAgcmV0dXJuIHRoaXMuX2Jhc2VfcmVhZFRva2VuKGNvZGUpXG5cbnBwLnBvcE9mZnNpZGUgPSBmdW5jdGlvbigpIDo6XG4gIGNvbnN0IHN0YWNrID0gdGhpcy5zdGF0ZS5vZmZzaWRlXG4gIGxldCBzdGFja1RvcCA9IHRoaXMuaXNMb29rYWhlYWRcbiAgICA/IHN0YWNrW3N0YWNrLmxlbmd0aC0xXVxuICAgIDogc3RhY2sucG9wKClcbiAgdGhpcy5zdGF0ZS5vZmZzaWRlUG9zID0gLTFcblxuICB0aGlzLl9iYXNlX2ZpbmlzaFRva2VuKHN0YWNrVG9wLm9wLnRva2VuUG9zdClcbiAgcmV0dXJuIHN0YWNrVG9wXG5cblxuXG5jb25zdCByeF9vZmZzaWRlID0gL14oWyBcXHRdKikoLiopJC9tZ1xuZnVuY3Rpb24gcGFyc2VPZmZzaWRlSW5kZXhNYXAoaW5wdXQpIDo6XG4gIGxldCBsaW5lcyA9IFtudWxsXSwgcG9zTGFzdENvbnRlbnQ9MCwgbGFzdD1bJycsIDBdXG5cbiAgbGV0IGFucyA9IGlucHV0LnJlcGxhY2UgQCByeF9vZmZzaWRlLCAobWF0Y2gsIGluZGVudCwgY29udGVudCwgcG9zKSA9PiA6OlxuICAgIGlmICghY29udGVudCkgOjpcbiAgICAgIFtpbmRlbnQsIHBvc0xhc3RDb250ZW50XSA9IGxhc3QgLy8gYmxhbmsgbGluZTsgdXNlIGxhc3QgdmFsaWQgY29udGVudCBhcyBlbmRcbiAgICBlbHNlIDo6XG4gICAgICAvLyB2YWxpZCBjb250ZW50OyBzZXQgbGFzdCB0byBjdXJyZW50IGluZGVudFxuICAgICAgcG9zTGFzdENvbnRlbnQgPSBwb3MgKyBtYXRjaC5sZW5ndGhcbiAgICAgIGxhc3QgPSBbaW5kZW50LCBwb3NMYXN0Q29udGVudF1cblxuICAgIGxpbmVzLnB1c2goe2xpbmU6IGxpbmVzLmxlbmd0aCwgcG9zTGFzdENvbnRlbnQsIGluZGVudCwgY29udGVudH0pXG4gICAgcmV0dXJuICcnXG5cbiAgcmV0dXJuIGxpbmVzXG5cblxuY29uc3Qga2V5d29yZF9ibG9ja19wYXJlbnRzID1cbiBAe30gSWZTdGF0ZW1lbnQ6ICdpZidcbiAgICwgRm9yU3RhdGVtZW50OiAnZm9yJ1xuICAgLCBGb3JPZlN0YXRlbWVudDogJ2ZvcidcbiAgICwgV2hpbGVTdGF0ZW1lbnQ6ICd3aGlsZSdcbiAgICwgRG9XaGlsZVN0YXRlbWVudDogJ2RvLXdoaWxlJ1xuY29uc3QgbGludF9rZXl3b3JkX2Jsb2NrX3BhcmVudHMgPSBuZXcgU2V0IEAgT2JqZWN0LmtleXMgQCBrZXl3b3JkX2Jsb2NrX3BhcmVudHNcblxuY29uc3QgYmFiZWxfcGx1Z2luX2lkID0gYGJhYmVsLXBsdWdpbi1vZmZzaWRlLS0ke0RhdGUubm93KCl9YFxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gKGJhYmVsKSA9PiA6OlxuICByZXR1cm4gOjpcbiAgICBuYW1lOiBiYWJlbF9wbHVnaW5faWRcbiAgICAsIHByZShzdGF0ZSkgOjpcbiAgICAgIHRoaXMub3B0cyA9IE9iamVjdC5hc3NpZ24gQCB7fSwgZGVmYXVsdF9vZmZzaWRlUGx1Z2luT3B0cywgdGhpcy5vcHRzXG5cbiAgICAsIG1hbmlwdWxhdGVPcHRpb25zKG9wdHMsIHBhcnNlck9wdHMpIDo6XG4gICAgICAgIHBhcnNlck9wdHMucGx1Z2lucy5wdXNoKCdkZWNvcmF0b3JzJywgJ2Z1bmN0aW9uQmluZCcpXG4gICAgICAgIGNvbnN0IG9mZnNpZGVQbHVnaW5PcHRzID0gb3B0cy5wbHVnaW5zXG4gICAgICAgICAgLmZpbHRlciBAIHBsdWdpbiA9PiBwbHVnaW5bMF0gJiYgYmFiZWxfcGx1Z2luX2lkID09PSBwbHVnaW5bMF0ua2V5ICYmIHBsdWdpblsxXVxuICAgICAgICAgIC5tYXAgQCBwbHVnaW4gPT4gcGx1Z2luWzFdXG4gICAgICAgICAgLnBvcCgpXG4gICAgICAgIHBhcnNlck9wdHMub2Zmc2lkZVBsdWdpbk9wdHMgPSBvZmZzaWRlUGx1Z2luT3B0cyB8fCBkZWZhdWx0X29mZnNpZGVQbHVnaW5PcHRzXG5cbiAgICAsIHZpc2l0b3I6IDo6XG4gICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQocGF0aCkgOjpcbiAgICAgICAgICBpZiAoIXRoaXMub3B0cy5rZXl3b3JkX2Jsb2NrcykgOjogcmV0dXJuXG4gICAgICAgICAgaWYgKCFsaW50X2tleXdvcmRfYmxvY2tfcGFyZW50cy5oYXMocGF0aC5wYXJlbnQudHlwZSkpIDo6IHJldHVyblxuXG4gICAgICAgICAgbGV0IGtleXdvcmQgPSBrZXl3b3JkX2Jsb2NrX3BhcmVudHNbcGF0aC5wYXJlbnQudHlwZV1cbiAgICAgICAgICBpZiAoJ2lmJyA9PT0ga2V5d29yZCAmJiBwYXRoLm5vZGUgPT09IHBhdGgucGFyZW50LmFsdGVybmF0ZSkgOjpcbiAgICAgICAgICAgIGtleXdvcmQgPSAnZWxzZScgLy8gZml4dXAgaWYvZWxzZSBjb21iaW5lZCBwYXJlbnQgY29uZGl0aW9uXG5cbiAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IgQFxuICAgICAgICAgICAgYEtleXdvcmQgJyR7a2V5d29yZH0nIHNob3VsZCBiZSBmb2xsb3dlZCBieSBhIGJsb2NrIHN0YXRlbWVudCB1c2luZyAnOjonIG9yIG1hdGNoaW5nICd7JyAvICd9Jy4gXFxuYCArXG4gICAgICAgICAgICBgICAgIChGcm9tICdrZXl3b3JkX2Jsb2NrcycgZW5mb3JjZW1lbnQgb3B0aW9uIG9mIGJhYmVsLXBsdWdpbi1vZmZzaWRlKWBcblxuXG5PYmplY3QuYXNzaWduIEAgZXhwb3J0cyxcbiAgQHt9XG4gICAgaG9va0JhYnlsb24sXG4gICAgcGFyc2VPZmZzaWRlSW5kZXhNYXAsXG5cbiJdfQ==